# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# deploy.yml - Reusable Deployment Workflow
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# REUSABLE WORKFLOW - Called by other repos via:
#   uses: signalwire-demos/dokku-deploy-system/.github/workflows/deploy.yml@main
#
# Automatically deploys to Dokku when pushing to main/staging/develop branches.
# Uses GitHub repository name as the Dokku app name.
#
# Required Secrets (set at org level):
#   - DOKKU_HOST: Dokku server hostname
#   - DOKKU_SSH_PRIVATE_KEY: SSH private key for deployment
#   - BASE_DOMAIN: Base domain for apps (e.g., yourdomain.com)
#
# Optional Secrets:
#   - SLACK_WEBHOOK_URL: Slack notifications
#   - DISCORD_WEBHOOK_URL: Discord notifications
#
# Branch â†’ Environment mapping:
#   - main    â†’ production  â†’ app.domain.com
#   - staging â†’ staging     â†’ app-staging.domain.com
#   - develop â†’ development â†’ app-dev.domain.com
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: Deploy to Dokku (Reusable)

on:
  workflow_call:
    inputs:
      health_check_path:
        description: 'Path for health check (default: /health)'
        required: false
        type: string
        default: '/health'
      memory_limit:
        description: 'Memory limit override (e.g., 512m)'
        required: false
        type: string
      cpu_limit:
        description: 'CPU limit override (e.g., 1)'
        required: false
        type: string
    secrets:
      DOKKU_HOST:
        required: true
      DOKKU_SSH_PRIVATE_KEY:
        required: true
      BASE_DOMAIN:
        required: true
      SLACK_WEBHOOK_URL:
        required: false
      DISCORD_WEBHOOK_URL:
        required: false

env:
  BASE_APP_NAME: ${{ github.event.repository.name }}

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Setup - Determine deployment environment
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  setup:
    name: Setup Environment
    runs-on: ubuntu-latest
    outputs:
      app_name: ${{ steps.env.outputs.app_name }}
      environment: ${{ steps.env.outputs.environment }}
    steps:
      - name: Create environments if needed
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          for env in production staging development preview; do
            gh api repos/${{ github.repository }}/environments/$env -X PUT 2>/dev/null || true
          done

      - name: Determine deployment environment
        id: env
        run: |
          BRANCH="${GITHUB_REF#refs/heads/}"
          BASE_APP="${{ env.BASE_APP_NAME }}"

          case "$BRANCH" in
            main)
              echo "app_name=${BASE_APP}" >> $GITHUB_OUTPUT
              echo "environment=production" >> $GITHUB_OUTPUT
              ;;
            staging)
              echo "app_name=${BASE_APP}-staging" >> $GITHUB_OUTPUT
              echo "environment=staging" >> $GITHUB_OUTPUT
              ;;
            develop)
              echo "app_name=${BASE_APP}-dev" >> $GITHUB_OUTPUT
              echo "environment=development" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "Unknown branch: $BRANCH"
              exit 1
              ;;
          esac

          echo "Branch: $BRANCH"
          echo "App Name: $(cat $GITHUB_OUTPUT | grep app_name | cut -d= -f2)"
          echo "Environment: $(cat $GITHUB_OUTPUT | grep environment | cut -d= -f2)"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Test - Run tests before deployment
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Detect and setup runtime
      - name: Detect runtime
        id: detect
        run: |
          if [ -f "package.json" ]; then
            echo "runtime=node" >> $GITHUB_OUTPUT
          elif [ -f "requirements.txt" ] || [ -f "pyproject.toml" ]; then
            echo "runtime=python" >> $GITHUB_OUTPUT
          elif [ -f "Gemfile" ]; then
            echo "runtime=ruby" >> $GITHUB_OUTPUT
          elif [ -f "go.mod" ]; then
            echo "runtime=go" >> $GITHUB_OUTPUT
          else
            echo "runtime=unknown" >> $GITHUB_OUTPUT
          fi

      # Node.js setup
      - name: Setup Node.js
        if: steps.detect.outputs.runtime == 'node'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install Node.js dependencies
        if: steps.detect.outputs.runtime == 'node'
        run: npm ci

      - name: Run Node.js tests
        if: steps.detect.outputs.runtime == 'node'
        run: npm test --if-present

      - name: Run Node.js lint
        if: steps.detect.outputs.runtime == 'node'
        run: npm run lint --if-present

      # Python setup
      - name: Setup Python
        if: steps.detect.outputs.runtime == 'python'
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install Python dependencies
        if: steps.detect.outputs.runtime == 'python'
        run: |
          pip install -r requirements.txt
          pip install pytest pytest-cov || true

      - name: Run Python tests
        if: steps.detect.outputs.runtime == 'python'
        run: |
          if [ -d "tests" ] || [ -f "test_*.py" ]; then
            pytest --tb=short || true
          else
            echo "No tests found"
          fi

      # Ruby setup
      - name: Setup Ruby
        if: steps.detect.outputs.runtime == 'ruby'
        uses: ruby/setup-ruby@v1
        with:
          bundler-cache: true

      - name: Run Ruby tests
        if: steps.detect.outputs.runtime == 'ruby'
        run: bundle exec rake test || bundle exec rspec || true

      # Go setup
      - name: Setup Go
        if: steps.detect.outputs.runtime == 'go'
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      - name: Run Go tests
        if: steps.detect.outputs.runtime == 'go'
        run: go test ./... || true

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Deploy - Deploy to Dokku
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  deploy:
    name: Deploy to ${{ needs.setup.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [setup, test]
    environment: ${{ needs.setup.outputs.environment }}

    env:
      APP_NAME: ${{ needs.setup.outputs.app_name }}
      ENVIRONMENT: ${{ needs.setup.outputs.environment }}
      DOMAIN: ${{ needs.setup.outputs.app_name }}.${{ secrets.BASE_DOMAIN }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history needed for git push

      - name: Setup SSH connection
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          # Add private key
          echo "${{ secrets.DOKKU_SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          # Add host to known_hosts
          ssh-keyscan -H ${{ secrets.DOKKU_HOST }} >> ~/.ssh/known_hosts 2>/dev/null

          # Create SSH config
          cat >> ~/.ssh/config << EOF
          Host dokku
            HostName ${{ secrets.DOKKU_HOST }}
            User dokku
            IdentityFile ~/.ssh/deploy_key
            StrictHostKeyChecking no
          EOF
          chmod 600 ~/.ssh/config

          # Test connection
          ssh dokku version

      - name: Create app if not exists
        id: create_app
        run: |
          echo "Checking if app exists: ${{ env.APP_NAME }}"
          if ssh dokku apps:exists ${{ env.APP_NAME }} 2>/dev/null; then
            echo "App already exists"
            echo "first_deploy=false" >> $GITHUB_OUTPUT
          else
            echo "Creating new app..."
            ssh dokku apps:create ${{ env.APP_NAME }}
            echo "first_deploy=true" >> $GITHUB_OUTPUT
          fi

      - name: Unlock app
        run: |
          ssh dokku apps:unlock ${{ env.APP_NAME }} 2>/dev/null || true

      - name: Provision services
        run: |
          if [ -f ".dokku/services.yml" ]; then
            echo "Found services manifest, provisioning..."

            # Install yq for YAML parsing
            sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
            sudo chmod +x /usr/local/bin/yq

            # PostgreSQL
            if yq e '.services.postgres.enabled' .dokku/services.yml 2>/dev/null | grep -q "true"; then
              DB_NAME="postgres-${{ env.APP_NAME }}"
              echo "Provisioning PostgreSQL: $DB_NAME"
              ssh dokku postgres:exists $DB_NAME 2>/dev/null || ssh dokku postgres:create $DB_NAME
              ssh dokku postgres:link $DB_NAME ${{ env.APP_NAME }} 2>/dev/null || true
            fi

            # Redis
            if yq e '.services.redis.enabled' .dokku/services.yml 2>/dev/null | grep -q "true"; then
              REDIS_NAME="redis-${{ env.APP_NAME }}"
              echo "Provisioning Redis: $REDIS_NAME"
              ssh dokku redis:exists $REDIS_NAME 2>/dev/null || ssh dokku redis:create $REDIS_NAME
              ssh dokku redis:link $REDIS_NAME ${{ env.APP_NAME }} 2>/dev/null || true
            fi

            # MongoDB
            if yq e '.services.mongo.enabled' .dokku/services.yml 2>/dev/null | grep -q "true"; then
              MONGO_NAME="mongo-${{ env.APP_NAME }}"
              echo "Provisioning MongoDB: $MONGO_NAME"
              ssh dokku mongo:exists $MONGO_NAME 2>/dev/null || ssh dokku mongo:create $MONGO_NAME
              ssh dokku mongo:link $MONGO_NAME ${{ env.APP_NAME }} 2>/dev/null || true
            fi

            # MySQL
            if yq e '.services.mysql.enabled' .dokku/services.yml 2>/dev/null | grep -q "true"; then
              MYSQL_NAME="mysql-${{ env.APP_NAME }}"
              echo "Provisioning MySQL: $MYSQL_NAME"
              ssh dokku mysql:exists $MYSQL_NAME 2>/dev/null || ssh dokku mysql:create $MYSQL_NAME
              ssh dokku mysql:link $MYSQL_NAME ${{ env.APP_NAME }} 2>/dev/null || true
            fi

            # RabbitMQ
            if yq e '.services.rabbitmq.enabled' .dokku/services.yml 2>/dev/null | grep -q "true"; then
              RABBITMQ_NAME="rabbitmq-${{ env.APP_NAME }}"
              echo "Provisioning RabbitMQ: $RABBITMQ_NAME"
              ssh dokku rabbitmq:exists $RABBITMQ_NAME 2>/dev/null || ssh dokku rabbitmq:create $RABBITMQ_NAME
              ssh dokku rabbitmq:link $RABBITMQ_NAME ${{ env.APP_NAME }} 2>/dev/null || true
            fi

            # Elasticsearch
            if yq e '.services.elasticsearch.enabled' .dokku/services.yml 2>/dev/null | grep -q "true"; then
              ES_NAME="elasticsearch-${{ env.APP_NAME }}"
              echo "Provisioning Elasticsearch: $ES_NAME"
              ssh dokku elasticsearch:exists $ES_NAME 2>/dev/null || ssh dokku elasticsearch:create $ES_NAME
              ssh dokku elasticsearch:link $ES_NAME ${{ env.APP_NAME }} 2>/dev/null || true
            fi
          else
            echo "No services manifest found"
          fi

      - name: Set environment variables
        env:
          ALL_VARS: ${{ toJSON(vars) }}
        run: |
          echo "Setting environment variables..."

          # Start with required vars
          CONFIG_VARS="APP_ENV=${{ env.ENVIRONMENT }} APP_NAME=${{ env.APP_NAME }} APP_URL=https://${{ env.DOMAIN }} AGENT_NAME=${{ env.APP_NAME }} GIT_REV=${{ github.sha }}"

          # Loop through all environment variables from GitHub environment
          for key in $(echo "$ALL_VARS" | jq -r 'keys[]'); do
            value=$(echo "$ALL_VARS" | jq -r --arg k "$key" '.[$k]')
            [ -n "$value" ] && CONFIG_VARS="$CONFIG_VARS $key=$value"
          done

          # Clear existing config and set fresh values to ensure changes are applied
          ssh dokku config:clear --no-restart ${{ env.APP_NAME }} 2>/dev/null || true
          ssh dokku config:set --no-restart ${{ env.APP_NAME }} $CONFIG_VARS

      - name: Configure domain
        run: |
          echo "Configuring domain: ${{ env.DOMAIN }}"
          ssh dokku domains:clear ${{ env.APP_NAME }} 2>/dev/null || true
          ssh dokku domains:add ${{ env.APP_NAME }} ${{ env.DOMAIN }}

      - name: Configure resources
        run: |
          # Use inputs if provided, otherwise check config.yml
          MEMORY="${{ inputs.memory_limit }}"
          CPU="${{ inputs.cpu_limit }}"

          if [ -f ".dokku/config.yml" ]; then
            # Install yq if not already installed
            which yq || sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
            sudo chmod +x /usr/local/bin/yq

            [ -z "$MEMORY" ] && MEMORY=$(yq e '.resources.memory // "512m"' .dokku/config.yml)
            [ -z "$CPU" ] && CPU=$(yq e '.resources.cpu // "1"' .dokku/config.yml)
          fi

          # Set defaults if still empty
          [ -z "$MEMORY" ] && MEMORY="512m"
          [ -z "$CPU" ] && CPU="1"

          echo "Setting resources: memory=$MEMORY, cpu=$CPU"
          ssh dokku resource:limit ${{ env.APP_NAME }} --memory $MEMORY --cpu $CPU || true

      - name: Deploy via git push
        run: |
          echo "Deploying to Dokku..."

          # Add dokku remote
          git remote add dokku dokku@${{ secrets.DOKKU_HOST }}:${{ env.APP_NAME }} 2>/dev/null || \
          git remote set-url dokku dokku@${{ secrets.DOKKU_HOST }}:${{ env.APP_NAME }}

          # Push to deploy
          GIT_SSH_COMMAND="ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no" \
            git push dokku HEAD:refs/heads/main --force

      - name: Enable SSL
        run: |
          echo "Enabling Let's Encrypt SSL..."
          ssh dokku letsencrypt:active ${{ env.APP_NAME }} 2>/dev/null || \
          ssh dokku letsencrypt:enable ${{ env.APP_NAME }} || true

      - name: Verify deployment
        run: |
          echo "Verifying deployment..."

          HEALTH_PATH="${{ inputs.health_check_path }}"
          [ -z "$HEALTH_PATH" ] && HEALTH_PATH="/health"
          HEALTH_URL="https://${{ env.DOMAIN }}${HEALTH_PATH}"

          # Skip SSL verification - we just deployed, we know it's our app
          # (GitHub runner CA store may not trust Let's Encrypt immediately)
          CURL_OPTS="-sk"

          # Retry health check with backoff (first deploy needs time for SSL)
          MAX_ATTEMPTS=6
          ATTEMPT=1
          WAIT_TIME=10

          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "Health check attempt $ATTEMPT/$MAX_ATTEMPTS (waiting ${WAIT_TIME}s)..."
            sleep $WAIT_TIME

            HTTP_STATUS=$(curl $CURL_OPTS -o /dev/null -w "%{http_code}" "$HEALTH_URL" 2>/dev/null || echo "000")

            if [ "$HTTP_STATUS" == "200" ]; then
              echo "âœ… Health check passed (HTTP $HTTP_STATUS)"
              break
            elif [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 400 ]; then
              echo "âœ… App is responding (HTTP $HTTP_STATUS)"
              break
            else
              echo "âš ï¸ Health check returned HTTP $HTTP_STATUS"
              if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
                echo ""
                echo "Health check failed after $MAX_ATTEMPTS attempts"
                echo "Recent logs:"
                ssh dokku logs ${{ env.APP_NAME }} --num 30
                exit 1
              fi
              ATTEMPT=$((ATTEMPT + 1))
              WAIT_TIME=$((WAIT_TIME + 10))
            fi
          done

          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  âœ… Deployment successful!"
          echo "  ğŸŒ https://${{ env.DOMAIN }}"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

      - name: Create GitHub deployment
        uses: actions/github-script@v7
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: '${{ env.ENVIRONMENT }}',
              auto_merge: false,
              required_contexts: []
            });

            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.data.id,
              state: 'success',
              environment_url: 'https://${{ env.DOMAIN }}',
              description: 'Deployed successfully'
            });

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Notify - Send deployment notifications
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [setup, deploy]
    if: always()

    env:
      APP_NAME: ${{ needs.setup.outputs.app_name }}
      ENVIRONMENT: ${{ needs.setup.outputs.environment }}
      DOMAIN: ${{ needs.setup.outputs.app_name }}.${{ secrets.BASE_DOMAIN }}

    steps:
      - name: Notify Slack
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          [ -z "$SLACK_WEBHOOK_URL" ] && exit 0
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            COLOR="good"
            STATUS="âœ… Deployed successfully"
          else
            COLOR="danger"
            STATUS="âŒ Deployment failed"
          fi

          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"attachments\": [{
                \"color\": \"$COLOR\",
                \"title\": \"$STATUS\",
                \"fields\": [
                  {\"title\": \"App\", \"value\": \"${{ env.APP_NAME }}\", \"short\": true},
                  {\"title\": \"Environment\", \"value\": \"${{ env.ENVIRONMENT }}\", \"short\": true},
                  {\"title\": \"Branch\", \"value\": \"${{ github.ref_name }}\", \"short\": true},
                  {\"title\": \"Actor\", \"value\": \"${{ github.actor }}\", \"short\": true},
                  {\"title\": \"URL\", \"value\": \"https://${{ env.DOMAIN }}\", \"short\": false}
                ],
                \"footer\": \"<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Workflow>\"
              }]
            }" \
            "$SLACK_WEBHOOK_URL" || true

      - name: Notify Discord
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          [ -z "$DISCORD_WEBHOOK_URL" ] && exit 0
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            COLOR=3066993
            TITLE="âœ… Deployment Successful"
          else
            COLOR=15158332
            TITLE="âŒ Deployment Failed"
          fi

          curl -H "Content-Type: application/json" \
            -d "{
              \"embeds\": [{
                \"title\": \"$TITLE\",
                \"color\": $COLOR,
                \"fields\": [
                  {\"name\": \"App\", \"value\": \"${{ env.APP_NAME }}\", \"inline\": true},
                  {\"name\": \"Environment\", \"value\": \"${{ env.ENVIRONMENT }}\", \"inline\": true},
                  {\"name\": \"Branch\", \"value\": \"${{ github.ref_name }}\", \"inline\": true},
                  {\"name\": \"URL\", \"value\": \"https://${{ env.DOMAIN }}\", \"inline\": false}
                ],
                \"footer\": {\"text\": \"Deployed by ${{ github.actor }}\"},
                \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
              }]
            }" \
            "$DISCORD_WEBHOOK_URL" || true
