# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# deploy.yml - Reusable Deployment Workflow
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# REUSABLE WORKFLOW - Called by other repos via:
#   uses: signalwire-demos/dokku-deploy-system/.github/workflows/deploy.yml@main
#
# Automatically deploys to Dokku when pushing to main/staging/develop branches.
# Uses GitHub repository name as the Dokku app name.
#
# Required Secrets (set at org level):
#   - DOKKU_HOST: Dokku server hostname
#   - DOKKU_SSH_PRIVATE_KEY: SSH private key for deployment
#   - BASE_DOMAIN: Base domain for apps (e.g., yourdomain.com)
#
# Optional Secrets:
#   - SLACK_WEBHOOK_URL: Slack notifications
#   - DISCORD_WEBHOOK_URL: Discord notifications
#
# Branch â†’ Environment mapping:
#   - main    â†’ production  â†’ app.domain.com
#   - staging â†’ staging     â†’ app-staging.domain.com
#   - develop â†’ development â†’ app-dev.domain.com
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: Deploy

on:
  workflow_call:
    inputs:
      health_check_path:
        description: 'Path for health check (default: /health)'
        required: false
        type: string
        default: '/health'
      memory_limit:
        description: 'Memory limit override (e.g., 512m)'
        required: false
        type: string
      cpu_limit:
        description: 'CPU limit override (e.g., 1)'
        required: false
        type: string
    secrets:
      DOKKU_HOST:
        required: true
      DOKKU_SSH_PRIVATE_KEY:
        required: true
      BASE_DOMAIN:
        required: true
      SLACK_WEBHOOK_URL:
        required: false
      DISCORD_WEBHOOK_URL:
        required: false

env:
  BASE_APP_NAME: ${{ github.event.repository.name }}

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Setup - Determine deployment environment
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  setup:
    name: Setup Environment
    runs-on: ubuntu-latest
    outputs:
      app_name: ${{ steps.env.outputs.app_name }}
      environment: ${{ steps.env.outputs.environment }}
      app_url: ${{ steps.env.outputs.app_url }}
    steps:
      - name: Create environments if needed
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          for env in production staging development preview; do
            gh api repos/${{ github.repository }}/environments/$env -X PUT 2>/dev/null || true
          done

      - name: Determine deployment environment
        id: env
        env:
          BASE_DOMAIN: ${{ secrets.BASE_DOMAIN }}
        run: |
          BRANCH="${GITHUB_REF#refs/heads/}"
          BASE_APP="${{ env.BASE_APP_NAME }}"

          case "$BRANCH" in
            main)
              APP_NAME="${BASE_APP}"
              echo "app_name=${APP_NAME}" >> $GITHUB_OUTPUT
              echo "environment=production" >> $GITHUB_OUTPUT
              ;;
            staging)
              APP_NAME="${BASE_APP}-staging"
              echo "app_name=${APP_NAME}" >> $GITHUB_OUTPUT
              echo "environment=staging" >> $GITHUB_OUTPUT
              ;;
            develop)
              APP_NAME="${BASE_APP}-dev"
              echo "app_name=${APP_NAME}" >> $GITHUB_OUTPUT
              echo "environment=development" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "Unknown branch: $BRANCH"
              exit 1
              ;;
          esac

          echo "app_url=https://${APP_NAME}.${BASE_DOMAIN}" >> $GITHUB_OUTPUT

          echo "Branch: $BRANCH"
          echo "App Name: ${APP_NAME}"
          echo "App URL: https://${APP_NAME}.${BASE_DOMAIN}"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Test - Run tests before deployment
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Detect and setup runtime
      - name: Detect runtime
        id: detect
        run: |
          if [ -f "package.json" ]; then
            echo "runtime=node" >> $GITHUB_OUTPUT
          elif [ -f "requirements.txt" ] || [ -f "pyproject.toml" ]; then
            echo "runtime=python" >> $GITHUB_OUTPUT
          elif [ -f "Gemfile" ]; then
            echo "runtime=ruby" >> $GITHUB_OUTPUT
          elif [ -f "go.mod" ]; then
            echo "runtime=go" >> $GITHUB_OUTPUT
          else
            echo "runtime=unknown" >> $GITHUB_OUTPUT
          fi

      # Node.js setup
      - name: Setup Node.js
        if: steps.detect.outputs.runtime == 'node'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install Node.js dependencies
        if: steps.detect.outputs.runtime == 'node'
        run: npm ci

      - name: Run Node.js tests
        if: steps.detect.outputs.runtime == 'node'
        run: npm test --if-present

      - name: Run Node.js lint
        if: steps.detect.outputs.runtime == 'node'
        run: npm run lint --if-present

      # Python setup
      - name: Setup Python
        if: steps.detect.outputs.runtime == 'python'
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install Python dependencies
        if: steps.detect.outputs.runtime == 'python'
        run: |
          pip install -r requirements.txt
          pip install pytest pytest-cov || true

      - name: Run Python tests
        if: steps.detect.outputs.runtime == 'python'
        run: |
          if [ -d "tests" ] || [ -f "test_*.py" ]; then
            pytest --tb=short || true
          else
            echo "No tests found"
          fi

      # Ruby setup
      - name: Setup Ruby
        if: steps.detect.outputs.runtime == 'ruby'
        uses: ruby/setup-ruby@v1
        with:
          bundler-cache: true

      - name: Run Ruby tests
        if: steps.detect.outputs.runtime == 'ruby'
        run: bundle exec rake test || bundle exec rspec || true

      # Go setup
      - name: Setup Go
        if: steps.detect.outputs.runtime == 'go'
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      - name: Run Go tests
        if: steps.detect.outputs.runtime == 'go'
        run: go test ./... || true

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Deploy - Deploy to Dokku
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  deploy:
    name: Deploy to ${{ needs.setup.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [setup, test]
    environment: ${{ needs.setup.outputs.environment }}
    outputs:
      duration: ${{ steps.deploy_info.outputs.duration }}
      commit_message: ${{ steps.deploy_info.outputs.commit_message }}
      files_changed: ${{ steps.deploy_info.outputs.files_changed }}
      previous_version: ${{ steps.deploy_info.outputs.previous_version }}
      current_version: ${{ steps.deploy_info.outputs.current_version }}

    env:
      APP_NAME: ${{ needs.setup.outputs.app_name }}
      ENVIRONMENT: ${{ needs.setup.outputs.environment }}
      DOMAIN: ${{ needs.setup.outputs.app_name }}.${{ secrets.BASE_DOMAIN }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history needed for git push

      - name: Setup SSH connection
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          # Add private key
          echo "${{ secrets.DOKKU_SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          # Add host to known_hosts
          ssh-keyscan -H ${{ secrets.DOKKU_HOST }} >> ~/.ssh/known_hosts 2>/dev/null

          # Create SSH config
          cat >> ~/.ssh/config << EOF
          Host dokku
            HostName ${{ secrets.DOKKU_HOST }}
            User dokku
            IdentityFile ~/.ssh/deploy_key
            StrictHostKeyChecking no
          EOF
          chmod 600 ~/.ssh/config

          # Test connection
          ssh dokku version

      - name: Record deploy start time
        id: timing
        run: echo "start_time=$(date +%s)" >> $GITHUB_OUTPUT

      - name: Check deploy lock
        run: |
          # Check if app exists first (can't check lock on non-existent app)
          if ssh dokku apps:exists ${{ env.APP_NAME }} 2>/dev/null; then
            LOCKED=$(ssh dokku config:get ${{ env.APP_NAME }} DEPLOY_LOCKED 2>/dev/null || echo "false")
            if [ "$LOCKED" == "true" ]; then
              REASON=$(ssh dokku config:get ${{ env.APP_NAME }} DEPLOY_LOCK_REASON 2>/dev/null || echo "No reason provided")
              LOCKED_BY=$(ssh dokku config:get ${{ env.APP_NAME }} DEPLOY_LOCK_BY 2>/dev/null || echo "Unknown")
              LOCKED_AT=$(ssh dokku config:get ${{ env.APP_NAME }} DEPLOY_LOCK_AT 2>/dev/null || echo "Unknown")
              echo ""
              echo "::error::Deployment blocked - App is locked!"
              echo ""
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo "  DEPLOY LOCK ACTIVE"
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo "  App: ${{ env.APP_NAME }}"
              echo "  Reason: $REASON"
              echo "  Locked by: $LOCKED_BY"
              echo "  Locked at: $LOCKED_AT"
              echo ""
              echo "  To unlock, run the Deploy Lock workflow with action=unlock"
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              exit 1
            fi
          fi
          echo "Deploy lock check passed"

      - name: Create app if not exists
        id: create_app
        run: |
          echo "Checking if app exists: ${{ env.APP_NAME }}"
          if ssh dokku apps:exists ${{ env.APP_NAME }} 2>/dev/null; then
            echo "App already exists"
            echo "first_deploy=false" >> $GITHUB_OUTPUT
          else
            echo "Creating new app..."
            ssh dokku apps:create ${{ env.APP_NAME }}
            echo "first_deploy=true" >> $GITHUB_OUTPUT
          fi

      - name: Unlock app
        run: |
          ssh dokku apps:unlock ${{ env.APP_NAME }} 2>/dev/null || true

      - name: Provision services
        run: |
          if [ -f ".dokku/services.yml" ]; then
            echo "Found services manifest, provisioning..."

            # Install yq for YAML parsing
            sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
            sudo chmod +x /usr/local/bin/yq

            # PostgreSQL
            if yq e '.services.postgres.enabled' .dokku/services.yml 2>/dev/null | grep -q "true"; then
              DB_NAME="postgres-${{ env.APP_NAME }}"
              echo "Provisioning PostgreSQL: $DB_NAME"
              ssh dokku postgres:exists $DB_NAME 2>/dev/null || ssh dokku postgres:create $DB_NAME
              ssh dokku postgres:link $DB_NAME ${{ env.APP_NAME }} 2>/dev/null || true
            fi

            # Redis
            if yq e '.services.redis.enabled' .dokku/services.yml 2>/dev/null | grep -q "true"; then
              REDIS_NAME="redis-${{ env.APP_NAME }}"
              echo "Provisioning Redis: $REDIS_NAME"
              ssh dokku redis:exists $REDIS_NAME 2>/dev/null || ssh dokku redis:create $REDIS_NAME
              ssh dokku redis:link $REDIS_NAME ${{ env.APP_NAME }} 2>/dev/null || true
            fi

            # MongoDB
            if yq e '.services.mongo.enabled' .dokku/services.yml 2>/dev/null | grep -q "true"; then
              MONGO_NAME="mongo-${{ env.APP_NAME }}"
              echo "Provisioning MongoDB: $MONGO_NAME"
              ssh dokku mongo:exists $MONGO_NAME 2>/dev/null || ssh dokku mongo:create $MONGO_NAME
              ssh dokku mongo:link $MONGO_NAME ${{ env.APP_NAME }} 2>/dev/null || true
            fi

            # MySQL
            if yq e '.services.mysql.enabled' .dokku/services.yml 2>/dev/null | grep -q "true"; then
              MYSQL_NAME="mysql-${{ env.APP_NAME }}"
              echo "Provisioning MySQL: $MYSQL_NAME"
              ssh dokku mysql:exists $MYSQL_NAME 2>/dev/null || ssh dokku mysql:create $MYSQL_NAME
              ssh dokku mysql:link $MYSQL_NAME ${{ env.APP_NAME }} 2>/dev/null || true
            fi

            # RabbitMQ
            if yq e '.services.rabbitmq.enabled' .dokku/services.yml 2>/dev/null | grep -q "true"; then
              RABBITMQ_NAME="rabbitmq-${{ env.APP_NAME }}"
              echo "Provisioning RabbitMQ: $RABBITMQ_NAME"
              ssh dokku rabbitmq:exists $RABBITMQ_NAME 2>/dev/null || ssh dokku rabbitmq:create $RABBITMQ_NAME
              ssh dokku rabbitmq:link $RABBITMQ_NAME ${{ env.APP_NAME }} 2>/dev/null || true
            fi

            # Elasticsearch
            if yq e '.services.elasticsearch.enabled' .dokku/services.yml 2>/dev/null | grep -q "true"; then
              ES_NAME="elasticsearch-${{ env.APP_NAME }}"
              echo "Provisioning Elasticsearch: $ES_NAME"
              ssh dokku elasticsearch:exists $ES_NAME 2>/dev/null || ssh dokku elasticsearch:create $ES_NAME
              ssh dokku elasticsearch:link $ES_NAME ${{ env.APP_NAME }} 2>/dev/null || true
            fi
          else
            echo "No services manifest found"
          fi

      - name: Set environment variables
        env:
          ALL_VARS: ${{ toJSON(vars) }}
        run: |
          echo "Setting environment variables..."

          # Start with required vars
          CONFIG_VARS="APP_ENV=${{ env.ENVIRONMENT }} APP_NAME=${{ env.APP_NAME }} APP_URL=https://${{ env.DOMAIN }} AGENT_NAME=${{ env.APP_NAME }} GIT_REV=${{ github.sha }}"

          # Loop through all environment variables from GitHub environment
          for key in $(echo "$ALL_VARS" | jq -r 'keys[]'); do
            value=$(echo "$ALL_VARS" | jq -r --arg k "$key" '.[$k]')
            [ -n "$value" ] && CONFIG_VARS="$CONFIG_VARS $key=$value"
          done

          # Clear existing config and set fresh values to ensure changes are applied
          ssh dokku config:clear --no-restart ${{ env.APP_NAME }} 2>/dev/null || true
          ssh dokku config:set --no-restart ${{ env.APP_NAME }} $CONFIG_VARS

      - name: Configure domains
        run: |
          echo "Configuring primary domain: ${{ env.DOMAIN }}"
          ssh dokku domains:clear ${{ env.APP_NAME }} 2>/dev/null || true
          ssh dokku domains:add ${{ env.APP_NAME }} ${{ env.DOMAIN }}

          # Add custom domains from config.yml if present
          if [ -f ".dokku/config.yml" ]; then
            # Install yq if not already installed
            which yq || sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
            sudo chmod +x /usr/local/bin/yq

            # Check for environment-specific custom domains first, then global
            ENV="${{ env.ENVIRONMENT }}"
            CUSTOM_DOMAINS=$(yq e ".environments.${ENV}.custom_domains // .custom_domains // []" .dokku/config.yml)

            if [ "$CUSTOM_DOMAINS" != "[]" ] && [ "$CUSTOM_DOMAINS" != "null" ]; then
              echo "Adding custom domains..."
              for domain in $(yq e ".environments.${ENV}.custom_domains // .custom_domains // [] | .[]" .dokku/config.yml); do
                echo "  Adding: $domain"
                ssh dokku domains:add ${{ env.APP_NAME }} "$domain" || true
              done
            fi
          fi

      - name: Configure resources
        run: |
          # Use inputs if provided, otherwise check config.yml
          MEMORY="${{ inputs.memory_limit }}"
          CPU="${{ inputs.cpu_limit }}"

          if [ -f ".dokku/config.yml" ]; then
            # Install yq if not already installed
            which yq || sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
            sudo chmod +x /usr/local/bin/yq

            [ -z "$MEMORY" ] && MEMORY=$(yq e '.resources.memory // "512m"' .dokku/config.yml)
            [ -z "$CPU" ] && CPU=$(yq e '.resources.cpu // "1"' .dokku/config.yml)
          fi

          # Set defaults if still empty
          [ -z "$MEMORY" ] && MEMORY="512m"
          [ -z "$CPU" ] && CPU="1"

          echo "Setting resources: memory=$MEMORY, cpu=$CPU"
          ssh dokku resource:limit ${{ env.APP_NAME }} --memory $MEMORY --cpu $CPU || true

      - name: Deploy via git push
        run: |
          echo "Deploying to Dokku..."

          # Add dokku remote
          git remote add dokku dokku@${{ secrets.DOKKU_HOST }}:${{ env.APP_NAME }} 2>/dev/null || \
          git remote set-url dokku dokku@${{ secrets.DOKKU_HOST }}:${{ env.APP_NAME }}

          # Push to deploy
          GIT_SSH_COMMAND="ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no" \
            git push dokku HEAD:refs/heads/main --force

      - name: Run release tasks
        run: |
          if [ ! -f ".dokku/config.yml" ]; then
            echo "No config.yml found, skipping release tasks"
            exit 0
          fi

          # Install yq if not already available
          which yq || sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

          # Get environment-specific tasks or fall back to global tasks
          ENV="${{ env.ENVIRONMENT }}"
          TASK_COUNT=$(yq e ".environments.${ENV}.release.tasks // .release.tasks // [] | length" .dokku/config.yml 2>/dev/null || echo "0")

          if [ "$TASK_COUNT" == "0" ] || [ -z "$TASK_COUNT" ]; then
            echo "No release tasks defined, skipping"
            exit 0
          fi

          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  Running $TASK_COUNT release task(s)..."
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          FAILED=0
          for i in $(seq 0 $((TASK_COUNT - 1))); do
            # Get task details (environment-specific or global)
            TASK_NAME=$(yq e ".environments.${ENV}.release.tasks[$i].name // .release.tasks[$i].name" .dokku/config.yml 2>/dev/null)
            TASK_CMD=$(yq e ".environments.${ENV}.release.tasks[$i].command // .release.tasks[$i].command" .dokku/config.yml 2>/dev/null)
            TASK_TIMEOUT=$(yq e ".environments.${ENV}.release.tasks[$i].timeout // .release.tasks[$i].timeout // 120" .dokku/config.yml 2>/dev/null)

            if [ -z "$TASK_CMD" ] || [ "$TASK_CMD" == "null" ]; then
              continue
            fi

            echo ""
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            echo "  Task $((i + 1))/$TASK_COUNT: $TASK_NAME"
            echo "  Command: $TASK_CMD"
            echo "  Timeout: ${TASK_TIMEOUT}s"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

            if timeout "$TASK_TIMEOUT" ssh dokku run ${{ env.APP_NAME }} $TASK_CMD; then
              echo "âœ… SUCCESS: $TASK_NAME"
            else
              echo "âŒ FAILED: $TASK_NAME"
              FAILED=1
              break
            fi
          done

          if [ "$FAILED" -eq 1 ]; then
            echo ""
            echo "::error::Release task failed: $TASK_NAME"
            exit 1
          fi

          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  All release tasks completed successfully!"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

      - name: Verify deployment
        run: |
          echo "Verifying deployment via HTTP..."

          HEALTH_PATH="${{ inputs.health_check_path }}"
          [ -z "$HEALTH_PATH" ] && HEALTH_PATH="/health"
          # Use HTTP for health check - SSL will be enabled next
          HEALTH_URL="http://${{ env.DOMAIN }}${HEALTH_PATH}"

          MAX_ATTEMPTS=6
          ATTEMPT=1
          WAIT_TIME=5

          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "Health check attempt $ATTEMPT/$MAX_ATTEMPTS (waiting ${WAIT_TIME}s)..."
            sleep $WAIT_TIME

            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_URL" 2>/dev/null || echo "000")

            if [ "$HTTP_STATUS" == "200" ]; then
              echo "âœ… Health check passed (HTTP $HTTP_STATUS)"
              break
            elif [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 400 ]; then
              echo "âœ… App is responding (HTTP $HTTP_STATUS)"
              break
            else
              echo "âš ï¸ Health check returned HTTP $HTTP_STATUS"
              if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
                echo ""
                echo "Health check failed after $MAX_ATTEMPTS attempts"
                echo "Recent logs:"
                ssh dokku logs ${{ env.APP_NAME }} --num 30
                exit 1
              fi
              ATTEMPT=$((ATTEMPT + 1))
              WAIT_TIME=$((WAIT_TIME + 5))
            fi
          done

      - name: Enable SSL
        run: |
          echo "Enabling Let's Encrypt SSL..."
          # letsencrypt:enable covers all domains on the app
          if ssh dokku letsencrypt:active ${{ env.APP_NAME }} 2>/dev/null; then
            echo "SSL already active, updating certificates..."
            ssh dokku letsencrypt:enable ${{ env.APP_NAME }} || true
          else
            ssh dokku letsencrypt:enable ${{ env.APP_NAME }}
          fi

          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  âœ… Deployment successful!"
          echo "  ğŸŒ https://${{ env.DOMAIN }}"
          # Show custom domains if configured
          ssh dokku domains:report ${{ env.APP_NAME }} --domains-app-vhosts 2>/dev/null | grep -v "${{ env.DOMAIN }}" | while read domain; do
            [ -n "$domain" ] && echo "  ğŸŒ https://$domain"
          done || true
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

      - name: Capture deploy info
        id: deploy_info
        run: |
          # Calculate duration
          END_TIME=$(date +%s)
          START_TIME="${{ steps.timing.outputs.start_time }}"
          DURATION=$((END_TIME - START_TIME))
          MINUTES=$((DURATION / 60))
          SECONDS=$((DURATION % 60))
          echo "duration=${MINUTES}m ${SECONDS}s" >> $GITHUB_OUTPUT

          # Commit message (first line, truncated to 100 chars)
          COMMIT_MSG=$(git log -1 --pretty=%s | head -c 100)
          echo "commit_message=$COMMIT_MSG" >> $GITHUB_OUTPUT

          # Files changed count (compared to parent commit)
          FILES_CHANGED=$(git diff --name-only HEAD~1 2>/dev/null | wc -l | tr -d ' ') || FILES_CHANGED="N/A"
          echo "files_changed=$FILES_CHANGED" >> $GITHUB_OUTPUT

          # Previous version (from Dokku config)
          PREV_VERSION=$(ssh dokku config:get ${{ env.APP_NAME }} GIT_REV 2>/dev/null || echo "none")
          echo "previous_version=${PREV_VERSION:0:7}" >> $GITHUB_OUTPUT

          # Current version
          echo "current_version=${GITHUB_SHA:0:7}" >> $GITHUB_OUTPUT

          echo "Deploy info captured:"
          echo "  Duration: ${MINUTES}m ${SECONDS}s"
          echo "  Commit: $COMMIT_MSG"
          echo "  Files changed: $FILES_CHANGED"
          echo "  Version: ${PREV_VERSION:0:7} -> ${GITHUB_SHA:0:7}"

      - name: Create GitHub deployment
        uses: actions/github-script@v7
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: '${{ env.ENVIRONMENT }}',
              auto_merge: false,
              required_contexts: []
            });

            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.data.id,
              state: 'success',
              environment_url: 'https://${{ env.DOMAIN }}',
              description: 'Deployed successfully'
            });

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Notify - Send deployment notifications
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [setup, deploy]
    if: always()

    env:
      APP_NAME: ${{ needs.setup.outputs.app_name }}
      ENVIRONMENT: ${{ needs.setup.outputs.environment }}
      DOMAIN: ${{ needs.setup.outputs.app_name }}.${{ secrets.BASE_DOMAIN }}

    steps:
      - name: Notify Slack
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          [ -z "$SLACK_WEBHOOK_URL" ] && exit 0
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            COLOR="good"
            STATUS="âœ… Deployed successfully"
          else
            COLOR="danger"
            STATUS="âŒ Deployment failed"
          fi

          # Get deploy info from outputs
          DURATION="${{ needs.deploy.outputs.duration }}"
          FILES_CHANGED="${{ needs.deploy.outputs.files_changed }}"
          PREV_VERSION="${{ needs.deploy.outputs.previous_version }}"
          CURR_VERSION="${{ needs.deploy.outputs.current_version }}"
          COMMIT_MSG="${{ needs.deploy.outputs.commit_message }}"

          # Build version string
          if [ "$PREV_VERSION" != "none" ] && [ -n "$PREV_VERSION" ]; then
            VERSION_STR="${PREV_VERSION} â†’ ${CURR_VERSION}"
          else
            VERSION_STR="${CURR_VERSION} (first deploy)"
          fi

          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"attachments\": [{
                \"color\": \"$COLOR\",
                \"title\": \"$STATUS\",
                \"fields\": [
                  {\"title\": \"App\", \"value\": \"${{ env.APP_NAME }}\", \"short\": true},
                  {\"title\": \"Environment\", \"value\": \"${{ env.ENVIRONMENT }}\", \"short\": true},
                  {\"title\": \"Duration\", \"value\": \"$DURATION\", \"short\": true},
                  {\"title\": \"Files Changed\", \"value\": \"$FILES_CHANGED\", \"short\": true},
                  {\"title\": \"Version\", \"value\": \"$VERSION_STR\", \"short\": true},
                  {\"title\": \"Actor\", \"value\": \"${{ github.actor }}\", \"short\": true},
                  {\"title\": \"Commit\", \"value\": \"$COMMIT_MSG\", \"short\": false},
                  {\"title\": \"URL\", \"value\": \"https://${{ env.DOMAIN }}\", \"short\": false}
                ],
                \"footer\": \"<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Workflow> | <${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}|View Commit>\"
              }]
            }" \
            "$SLACK_WEBHOOK_URL" || true

      - name: Notify Discord
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          [ -z "$DISCORD_WEBHOOK_URL" ] && exit 0
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            COLOR=3066993
            TITLE="âœ… Deployment Successful"
          else
            COLOR=15158332
            TITLE="âŒ Deployment Failed"
          fi

          curl -H "Content-Type: application/json" \
            -d "{
              \"embeds\": [{
                \"title\": \"$TITLE\",
                \"color\": $COLOR,
                \"fields\": [
                  {\"name\": \"App\", \"value\": \"${{ env.APP_NAME }}\", \"inline\": true},
                  {\"name\": \"Environment\", \"value\": \"${{ env.ENVIRONMENT }}\", \"inline\": true},
                  {\"name\": \"Branch\", \"value\": \"${{ github.ref_name }}\", \"inline\": true},
                  {\"name\": \"URL\", \"value\": \"https://${{ env.DOMAIN }}\", \"inline\": false}
                ],
                \"footer\": {\"text\": \"Deployed by ${{ github.actor }}\"},
                \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
              }]
            }" \
            "$DISCORD_WEBHOOK_URL" || true

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Update Dashboard - Update the deployment dashboard
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  update-dashboard:
    name: Update Dashboard
    needs: [setup, deploy]
    if: always()
    uses: ./.github/workflows/update-dashboard.yml
    with:
      app_name: ${{ needs.setup.outputs.app_name }}
      action: deploy
      status: ${{ needs.deploy.result }}
      environment: ${{ needs.setup.outputs.environment }}
      url: ${{ needs.setup.outputs.app_url }}
      commit_sha: ${{ github.sha }}
      actor: ${{ github.actor }}
    secrets: inherit
