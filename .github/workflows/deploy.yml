# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# deploy.yml - Reusable Deployment Workflow
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# REUSABLE WORKFLOW - Called by other repos via:
#   uses: signalwire-demos/dokku-deploy-system/.github/workflows/deploy.yml@main
#
# Automatically deploys to Dokku when pushing to main/staging/develop branches.
# Uses GitHub repository name as the Dokku app name.
#
# Required Secrets (set at org level):
#   - DOKKU_HOST: Dokku server hostname
#   - DOKKU_SSH_PRIVATE_KEY: SSH private key for deployment
#
# Required Variables (set at org level - Settings â†’ Variables â†’ New org variable):
#   - BASE_DOMAIN: Base domain for apps (e.g., yourdomain.com)
#
# Optional Secrets:
#   - SLACK_WEBHOOK_URL: Slack notifications
#   - DISCORD_WEBHOOK_URL: Discord notifications
#
# Branch â†’ Environment mapping:
#   - main    â†’ production  â†’ app.domain.com
#   - staging â†’ staging     â†’ app-staging.domain.com
#   - develop â†’ development â†’ app-dev.domain.com
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: Deploy

on:
  workflow_call:
    inputs:
      health_check_path:
        description: 'Path for health check (default: /health)'
        required: false
        type: string
        default: '/health'
      memory_limit:
        description: 'Memory limit override (e.g., 512m)'
        required: false
        type: string
      cpu_limit:
        description: 'CPU limit override (e.g., 1)'
        required: false
        type: string
    secrets:
      DOKKU_HOST:
        required: true
      DOKKU_SSH_PRIVATE_KEY:
        required: true
      GH_ORG_TOKEN:
        required: false
      SLACK_WEBHOOK_URL:
        required: false
      DISCORD_WEBHOOK_URL:
        required: false
      DEPLOY_WEBHOOK_URLS:
        required: false
      DEPLOY_WEBHOOK_SECRET:
        required: false
      DD_API_KEY:
        required: false
      PAGERDUTY_ROUTING_KEY:
        required: false

env:
  BASE_APP_NAME: ${{ github.event.repository.name }}

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Setup - Determine deployment environment
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  setup:
    name: Setup Environment
    runs-on: ubuntu-latest
    outputs:
      app_name: ${{ steps.env.outputs.app_name }}
      environment: ${{ steps.env.outputs.environment }}
      app_url: ${{ steps.env.outputs.app_url }}
    steps:
      - name: Create environments if needed
        env:
          GH_TOKEN: ${{ secrets.GH_ORG_TOKEN || github.token }}
        run: |
          for env in production staging development preview; do
            gh api repos/${{ github.repository }}/environments/$env -X PUT 2>/dev/null || true
          done

      - name: Determine deployment environment
        id: env
        env:
          BASE_DOMAIN: ${{ vars.BASE_DOMAIN }}
        run: |
          BRANCH="${GITHUB_REF#refs/heads/}"
          BASE_APP="${{ env.BASE_APP_NAME }}"

          case "$BRANCH" in
            main)
              APP_NAME="${BASE_APP}"
              echo "app_name=${APP_NAME}" >> $GITHUB_OUTPUT
              echo "environment=production" >> $GITHUB_OUTPUT
              ;;
            staging)
              APP_NAME="${BASE_APP}-staging"
              echo "app_name=${APP_NAME}" >> $GITHUB_OUTPUT
              echo "environment=staging" >> $GITHUB_OUTPUT
              ;;
            develop)
              APP_NAME="${BASE_APP}-dev"
              echo "app_name=${APP_NAME}" >> $GITHUB_OUTPUT
              echo "environment=development" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "Unknown branch: $BRANCH"
              exit 1
              ;;
          esac

          echo "app_url=https://${APP_NAME}.${BASE_DOMAIN}" >> $GITHUB_OUTPUT

          echo "Branch: $BRANCH"
          echo "App Name: ${APP_NAME}"
          echo "App URL: https://${APP_NAME}.${BASE_DOMAIN}"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Test - Run tests before deployment
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Detect and setup runtime
      - name: Detect runtime
        id: detect
        run: |
          if [ -f "package.json" ]; then
            echo "runtime=node" >> $GITHUB_OUTPUT
          elif [ -f "requirements.txt" ] || [ -f "pyproject.toml" ]; then
            echo "runtime=python" >> $GITHUB_OUTPUT
          elif [ -f "Gemfile" ]; then
            echo "runtime=ruby" >> $GITHUB_OUTPUT
          elif [ -f "go.mod" ]; then
            echo "runtime=go" >> $GITHUB_OUTPUT
          else
            echo "runtime=unknown" >> $GITHUB_OUTPUT
          fi

      # Node.js setup
      - name: Setup Node.js
        if: steps.detect.outputs.runtime == 'node'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install Node.js dependencies
        if: steps.detect.outputs.runtime == 'node'
        run: npm ci

      - name: Run Node.js tests
        if: steps.detect.outputs.runtime == 'node'
        run: npm test --if-present

      - name: Run Node.js lint
        if: steps.detect.outputs.runtime == 'node'
        run: npm run lint --if-present

      # Python setup
      - name: Setup Python
        if: steps.detect.outputs.runtime == 'python'
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install Python dependencies
        if: steps.detect.outputs.runtime == 'python'
        run: |
          pip install -r requirements.txt
          pip install pytest pytest-cov || true

      - name: Run Python tests
        if: steps.detect.outputs.runtime == 'python'
        run: |
          if [ -d "tests" ] || [ -f "test_*.py" ]; then
            pytest --tb=short || true
          else
            echo "No tests found"
          fi

      # Ruby setup
      - name: Setup Ruby
        if: steps.detect.outputs.runtime == 'ruby'
        uses: ruby/setup-ruby@v1
        with:
          bundler-cache: true

      - name: Run Ruby tests
        if: steps.detect.outputs.runtime == 'ruby'
        run: bundle exec rake test || bundle exec rspec || true

      # Go setup
      - name: Setup Go
        if: steps.detect.outputs.runtime == 'go'
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      - name: Run Go tests
        if: steps.detect.outputs.runtime == 'go'
        run: go test ./... || true

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Security Scan - Scan dependencies for vulnerabilities
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    outputs:
      critical_count: ${{ steps.scan.outputs.critical }}
      high_count: ${{ steps.scan.outputs.high }}
      scan_passed: ${{ steps.check.outputs.passed }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'json'
          output: 'trivy-results.json'
          severity: 'CRITICAL,HIGH,MEDIUM'

      - name: Parse scan results
        id: scan
        run: |
          if [ -f trivy-results.json ]; then
            CRITICAL=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL")] | length' trivy-results.json 2>/dev/null || echo "0")
            HIGH=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH")] | length' trivy-results.json 2>/dev/null || echo "0")
            MEDIUM=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "MEDIUM")] | length' trivy-results.json 2>/dev/null || echo "0")
          else
            CRITICAL=0
            HIGH=0
            MEDIUM=0
          fi

          echo "critical=$CRITICAL" >> $GITHUB_OUTPUT
          echo "high=$HIGH" >> $GITHUB_OUTPUT
          echo "medium=$MEDIUM" >> $GITHUB_OUTPUT

          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  Security Scan Results"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  Critical: $CRITICAL"
          echo "  High:     $HIGH"
          echo "  Medium:   $MEDIUM"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

      - name: Generate scan summary
        run: |
          echo "## ğŸ”’ Security Scan Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Severity | Count |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Critical | ${{ steps.scan.outputs.critical }} |" >> $GITHUB_STEP_SUMMARY
          echo "| High | ${{ steps.scan.outputs.high }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Medium | ${{ steps.scan.outputs.medium }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Add vulnerability details if any found
          if [ -f trivy-results.json ]; then
            TOTAL=$(( ${{ steps.scan.outputs.critical }} + ${{ steps.scan.outputs.high }} ))
            if [ "$TOTAL" -gt 0 ]; then
              echo "### Vulnerability Details" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "| Severity | Package | Vulnerability | Fixed Version |" >> $GITHUB_STEP_SUMMARY
              echo "|----------|---------|---------------|---------------|" >> $GITHUB_STEP_SUMMARY

              # Extract CRITICAL and HIGH vulnerabilities
              jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL" or .Severity == "HIGH") | "| \(.Severity) | \(.PkgName) | [\(.VulnerabilityID)](https://nvd.nist.gov/vuln/detail/\(.VulnerabilityID)) | \(.FixedVersion // "N/A") |"' trivy-results.json >> $GITHUB_STEP_SUMMARY 2>/dev/null || true

              echo "" >> $GITHUB_STEP_SUMMARY
              echo "<details><summary>How to fix</summary>" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**Option 1: Update the package** to the fixed version shown above" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**Option 2: Ignore if false positive** - create \`.trivyignore\` file in repo root:" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL" or .Severity == "HIGH") | .VulnerabilityID' trivy-results.json 2>/dev/null | head -10 >> $GITHUB_STEP_SUMMARY || true
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**Option 3: Disable blocking** - add to \`.dokku/config.yml\`:" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo '```yaml' >> $GITHUB_STEP_SUMMARY
              echo "security:" >> $GITHUB_STEP_SUMMARY
              echo "  block_on_critical: false" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "</details>" >> $GITHUB_STEP_SUMMARY
            fi
          fi

      - name: Check vulnerability thresholds
        id: check
        run: |
          CRITICAL="${{ steps.scan.outputs.critical }}"
          HIGH="${{ steps.scan.outputs.high }}"

          # Check for ignore file
          IGNORE_CRITICAL=false
          if [ -f ".dokku/security-ignore.yml" ] || [ -f ".trivyignore" ]; then
            echo "Security ignore file found - some vulnerabilities may be whitelisted"
          fi

          # Block on critical vulnerabilities (configurable via .dokku/config.yml)
          if [ "$CRITICAL" -gt 0 ]; then
            echo "::warning::$CRITICAL critical vulnerabilities found"
            echo "passed=false" >> $GITHUB_OUTPUT
            echo ""
            echo "âŒ Critical vulnerabilities detected!"
            echo "   Review the scan results and either:"
            echo "   1. Fix the vulnerabilities"
            echo "   2. Add to .trivyignore if it's a false positive"
            echo "   3. Set security.block_on_critical: false in .dokku/config.yml"
            # Don't exit 1 - let the deploy job decide based on config
          else
            echo "passed=true" >> $GITHUB_OUTPUT
            echo "âœ… No critical vulnerabilities found"
          fi

      - name: Upload scan results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-scan-results
          path: trivy-results.json
          retention-days: 30

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Deploy - Deploy to Dokku
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  deploy:
    name: Deploy to ${{ needs.setup.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [setup, test, security-scan]
    environment: ${{ needs.setup.outputs.environment }}
    outputs:
      duration: ${{ steps.deploy_info.outputs.duration }}
      commit_message: ${{ steps.deploy_info.outputs.commit_message }}
      files_changed: ${{ steps.deploy_info.outputs.files_changed }}
      previous_version: ${{ steps.deploy_info.outputs.previous_version }}
      current_version: ${{ steps.deploy_info.outputs.current_version }}

    env:
      APP_NAME: ${{ needs.setup.outputs.app_name }}
      ENVIRONMENT: ${{ needs.setup.outputs.environment }}
      DOMAIN: ${{ needs.setup.outputs.app_name }}.${{ vars.BASE_DOMAIN }}

    steps:
      - name: Set pending commit status
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_ORG_TOKEN || github.token }}
          script: |
            try {
              await github.rest.repos.createCommitStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                sha: context.sha,
                state: 'pending',
                context: 'deploy/${{ env.ENVIRONMENT }}',
                description: 'Deployment in progress...',
                target_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
              });
            } catch (e) {
              console.log('Could not set commit status (missing statuses permission):', e.message);
            }

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history needed for git push

      - name: Check security scan results
        run: |
          CRITICAL="${{ needs.security-scan.outputs.critical_count }}"
          SCAN_PASSED="${{ needs.security-scan.outputs.scan_passed }}"

          # Check if blocking is disabled in config
          BLOCK_CRITICAL=true
          if [ -f ".dokku/config.yml" ]; then
            # Install yq for YAML parsing
            which yq || {
              sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
              sudo chmod +x /usr/local/bin/yq
            }
            BLOCK_CRITICAL=$(yq e '.security.block_on_critical // true' .dokku/config.yml 2>/dev/null || echo "true")
          fi

          if [ "$SCAN_PASSED" == "false" ] && [ "$BLOCK_CRITICAL" == "true" ]; then
            echo ""
            echo "::error::Deployment blocked: $CRITICAL critical vulnerabilities found"
            echo ""
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "  ğŸš¨ SECURITY BLOCK"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "  Critical vulnerabilities: $CRITICAL"
            echo ""
            echo "  To proceed, either:"
            echo "  1. Fix the vulnerabilities"
            echo "  2. Add exceptions to .trivyignore"
            echo "  3. Set in .dokku/config.yml:"
            echo "     security:"
            echo "       block_on_critical: false"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            exit 1
          fi

          echo "âœ… Security check passed"

      - name: Setup SSH connection
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          # Add private key
          echo "${{ secrets.DOKKU_SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          # Add host to known_hosts
          ssh-keyscan -H ${{ secrets.DOKKU_HOST }} >> ~/.ssh/known_hosts 2>/dev/null

          # Create SSH config
          cat >> ~/.ssh/config << EOF
          Host dokku
            HostName ${{ secrets.DOKKU_HOST }}
            User dokku
            IdentityFile ~/.ssh/deploy_key
            StrictHostKeyChecking no
          EOF
          chmod 600 ~/.ssh/config

          # Test connection
          ssh dokku version

      - name: Record deploy start time
        id: timing
        run: echo "start_time=$(date +%s)" >> $GITHUB_OUTPUT

      - name: Check deploy lock
        run: |
          # Check if app exists first (can't check lock on non-existent app)
          if ssh dokku apps:exists ${{ env.APP_NAME }} 2>/dev/null; then
            LOCKED=$(ssh dokku config:get ${{ env.APP_NAME }} DEPLOY_LOCKED 2>/dev/null || echo "false")
            if [ "$LOCKED" == "true" ]; then
              REASON=$(ssh dokku config:get ${{ env.APP_NAME }} DEPLOY_LOCK_REASON 2>/dev/null || echo "No reason provided")
              LOCKED_BY=$(ssh dokku config:get ${{ env.APP_NAME }} DEPLOY_LOCK_BY 2>/dev/null || echo "Unknown")
              LOCKED_AT=$(ssh dokku config:get ${{ env.APP_NAME }} DEPLOY_LOCK_AT 2>/dev/null || echo "Unknown")
              echo ""
              echo "::error::Deployment blocked - App is locked!"
              echo ""
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo "  DEPLOY LOCK ACTIVE"
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo "  App: ${{ env.APP_NAME }}"
              echo "  Reason: $REASON"
              echo "  Locked by: $LOCKED_BY"
              echo "  Locked at: $LOCKED_AT"
              echo ""
              echo "  To unlock, run the Deploy Lock workflow with action=unlock"
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              exit 1
            fi
          fi
          echo "Deploy lock check passed"

      - name: Create app if not exists
        id: create_app
        run: |
          echo "Checking if app exists: ${{ env.APP_NAME }}"
          if ssh dokku apps:exists ${{ env.APP_NAME }} 2>/dev/null; then
            echo "App already exists"
            echo "first_deploy=false" >> $GITHUB_OUTPUT
          else
            echo "Creating new app..."
            ssh dokku apps:create ${{ env.APP_NAME }}
            echo "first_deploy=true" >> $GITHUB_OUTPUT
          fi

      - name: Unlock app
        run: |
          ssh dokku apps:unlock ${{ env.APP_NAME }} 2>/dev/null || true

      - name: Provision services
        run: |
          if [ -f ".dokku/services.yml" ]; then
            echo "Found services manifest, provisioning..."

            # Install yq for YAML parsing
            sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
            sudo chmod +x /usr/local/bin/yq

            # PostgreSQL
            if yq e '.services.postgres.enabled' .dokku/services.yml 2>/dev/null | grep -q "true"; then
              DB_NAME="postgres-${{ env.APP_NAME }}"
              echo "Provisioning PostgreSQL: $DB_NAME"
              ssh dokku postgres:exists $DB_NAME 2>/dev/null || ssh dokku postgres:create $DB_NAME
              ssh dokku postgres:link $DB_NAME ${{ env.APP_NAME }} 2>/dev/null || true
            fi

            # Redis
            if yq e '.services.redis.enabled' .dokku/services.yml 2>/dev/null | grep -q "true"; then
              REDIS_NAME="redis-${{ env.APP_NAME }}"
              echo "Provisioning Redis: $REDIS_NAME"
              ssh dokku redis:exists $REDIS_NAME 2>/dev/null || ssh dokku redis:create $REDIS_NAME
              ssh dokku redis:link $REDIS_NAME ${{ env.APP_NAME }} 2>/dev/null || true
            fi

            # MongoDB
            if yq e '.services.mongo.enabled' .dokku/services.yml 2>/dev/null | grep -q "true"; then
              MONGO_NAME="mongo-${{ env.APP_NAME }}"
              echo "Provisioning MongoDB: $MONGO_NAME"
              ssh dokku mongo:exists $MONGO_NAME 2>/dev/null || ssh dokku mongo:create $MONGO_NAME
              ssh dokku mongo:link $MONGO_NAME ${{ env.APP_NAME }} 2>/dev/null || true
            fi

            # MySQL
            if yq e '.services.mysql.enabled' .dokku/services.yml 2>/dev/null | grep -q "true"; then
              MYSQL_NAME="mysql-${{ env.APP_NAME }}"
              echo "Provisioning MySQL: $MYSQL_NAME"
              ssh dokku mysql:exists $MYSQL_NAME 2>/dev/null || ssh dokku mysql:create $MYSQL_NAME
              ssh dokku mysql:link $MYSQL_NAME ${{ env.APP_NAME }} 2>/dev/null || true
            fi

            # RabbitMQ
            if yq e '.services.rabbitmq.enabled' .dokku/services.yml 2>/dev/null | grep -q "true"; then
              RABBITMQ_NAME="rabbitmq-${{ env.APP_NAME }}"
              echo "Provisioning RabbitMQ: $RABBITMQ_NAME"
              ssh dokku rabbitmq:exists $RABBITMQ_NAME 2>/dev/null || ssh dokku rabbitmq:create $RABBITMQ_NAME
              ssh dokku rabbitmq:link $RABBITMQ_NAME ${{ env.APP_NAME }} 2>/dev/null || true
            fi

            # Elasticsearch
            if yq e '.services.elasticsearch.enabled' .dokku/services.yml 2>/dev/null | grep -q "true"; then
              ES_NAME="elasticsearch-${{ env.APP_NAME }}"
              echo "Provisioning Elasticsearch: $ES_NAME"
              ssh dokku elasticsearch:exists $ES_NAME 2>/dev/null || ssh dokku elasticsearch:create $ES_NAME
              ssh dokku elasticsearch:link $ES_NAME ${{ env.APP_NAME }} 2>/dev/null || true
            fi
          else
            echo "No services manifest found"
          fi

      - name: Set environment variables
        env:
          ALL_VARS: ${{ toJSON(vars) }}
        run: |
          echo "Setting environment variables..."

          # Start with required vars
          CONFIG_VARS="APP_ENV=${{ env.ENVIRONMENT }} APP_NAME=${{ env.APP_NAME }} APP_URL=https://${{ env.DOMAIN }} AGENT_NAME=${{ env.APP_NAME }} GIT_REV=${{ github.sha }}"

          # Loop through all environment variables from GitHub environment
          for key in $(echo "$ALL_VARS" | jq -r 'keys[]'); do
            value=$(echo "$ALL_VARS" | jq -r --arg k "$key" '.[$k]')
            [ -n "$value" ] && CONFIG_VARS="$CONFIG_VARS $key=$value"
          done

          # Clear existing config and set fresh values to ensure changes are applied
          ssh dokku config:clear --no-restart ${{ env.APP_NAME }} 2>/dev/null || true
          ssh dokku config:set --no-restart ${{ env.APP_NAME }} $CONFIG_VARS

      - name: Configure domains
        run: |
          echo "Configuring primary domain: ${{ env.DOMAIN }}"
          ssh dokku domains:clear ${{ env.APP_NAME }} 2>/dev/null || true
          ssh dokku domains:add ${{ env.APP_NAME }} ${{ env.DOMAIN }}

          # Add custom domains from config.yml if present
          if [ -f ".dokku/config.yml" ]; then
            # Install yq if not already installed
            which yq || sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
            sudo chmod +x /usr/local/bin/yq

            # Check for environment-specific custom domains first, then global
            ENV="${{ env.ENVIRONMENT }}"
            CUSTOM_DOMAINS=$(yq e ".environments.${ENV}.custom_domains // .custom_domains // []" .dokku/config.yml)

            if [ "$CUSTOM_DOMAINS" != "[]" ] && [ "$CUSTOM_DOMAINS" != "null" ]; then
              echo "Adding custom domains..."
              for domain in $(yq e ".environments.${ENV}.custom_domains // .custom_domains // [] | .[]" .dokku/config.yml); do
                echo "  Adding: $domain"
                ssh dokku domains:add ${{ env.APP_NAME }} "$domain" || true
              done
            fi
          fi

      - name: Configure resources and scaling
        run: |
          # Check if resource plugin is available
          RESOURCE_PLUGIN_AVAILABLE=false
          if ssh dokku resource:report 2>&1 | grep -q "resource"; then
            RESOURCE_PLUGIN_AVAILABLE=true
            echo "âœ… Resource plugin available"
          else
            echo "âš ï¸ Resource plugin not installed - skipping resource limits"
            echo "   Install with: sudo dokku plugin:install https://github.com/dokku/dokku-resource.git"
          fi

          # Use inputs if provided, otherwise check config.yml
          MEMORY="${{ inputs.memory_limit }}"
          CPU="${{ inputs.cpu_limit }}"
          WEB_SCALE=""
          WORKER_SCALE=""

          if [ -f ".dokku/config.yml" ]; then
            # Install yq if not already installed
            which yq || sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
            sudo chmod +x /usr/local/bin/yq

            ENV="${{ env.ENVIRONMENT }}"

            # Get environment-specific settings first, fall back to defaults
            [ -z "$MEMORY" ] && MEMORY=$(yq e ".environments.${ENV}.resources.memory // .resources.memory // \"512m\"" .dokku/config.yml)
            [ -z "$CPU" ] && CPU=$(yq e ".environments.${ENV}.resources.cpu // .resources.cpu // \"1\"" .dokku/config.yml)

            # Get scaling settings
            WEB_SCALE=$(yq e ".environments.${ENV}.scale.web // .scale.web // \"\"" .dokku/config.yml)
            WORKER_SCALE=$(yq e ".environments.${ENV}.scale.worker // .scale.worker // \"\"" .dokku/config.yml)
          fi

          # Set defaults if still empty
          [ -z "$MEMORY" ] || [ "$MEMORY" == "null" ] && MEMORY="512m"
          [ -z "$CPU" ] || [ "$CPU" == "null" ] && CPU="1"

          # Apply resource limits if plugin is available
          if [ "$RESOURCE_PLUGIN_AVAILABLE" == "true" ]; then
            echo "Setting resources: memory=$MEMORY, cpu=$CPU"
            ssh dokku resource:limit --memory $MEMORY --cpu $CPU ${{ env.APP_NAME }} || {
              echo "::warning::Failed to set resource limits"
            }
          else
            # Set WEB_CONCURRENCY as fallback for memory-aware workers
            echo "Setting WEB_CONCURRENCY based on memory limit..."
            # Extract numeric value from memory (e.g., "512m" -> 512, "1g" -> 1024)
            MEM_NUM=$(echo "$MEMORY" | sed 's/[^0-9]//g')
            MEM_UNIT=$(echo "$MEMORY" | sed 's/[0-9]//g')
            if [ "$MEM_UNIT" == "g" ]; then
              MEM_MB=$((MEM_NUM * 1024))
            else
              MEM_MB=$MEM_NUM
            fi
            # ~128MB per worker is reasonable for most Python/Node apps
            WEB_CONCURRENCY=$((MEM_MB / 128))
            [ "$WEB_CONCURRENCY" -lt 1 ] && WEB_CONCURRENCY=1
            [ "$WEB_CONCURRENCY" -gt 8 ] && WEB_CONCURRENCY=8
            ssh dokku config:set --no-restart ${{ env.APP_NAME }} WEB_CONCURRENCY=$WEB_CONCURRENCY || true
            echo "Set WEB_CONCURRENCY=$WEB_CONCURRENCY (based on ${MEMORY} memory)"
          fi

          # Apply process scaling
          SCALE_ARGS=""
          [ -n "$WEB_SCALE" ] && [ "$WEB_SCALE" != "null" ] && SCALE_ARGS="web=$WEB_SCALE"
          [ -n "$WORKER_SCALE" ] && [ "$WORKER_SCALE" != "null" ] && SCALE_ARGS="$SCALE_ARGS worker=$WORKER_SCALE"

          if [ -n "$SCALE_ARGS" ]; then
            echo "Setting process scale: $SCALE_ARGS"
            ssh dokku ps:scale ${{ env.APP_NAME }} $SCALE_ARGS 2>&1 || {
              # Check if it failed due to app.json formation
              if ssh dokku ps:scale ${{ env.APP_NAME }} 2>&1 | grep -q "app.json"; then
                echo "â„¹ï¸ Scaling controlled by app.json formation - skipping manual scale"
              else
                echo "::warning::Failed to set process scaling"
              fi
            }
          fi

      - name: Deploy via git push
        run: |
          echo "Deploying to Dokku..."

          # Add dokku remote
          git remote add dokku dokku@${{ secrets.DOKKU_HOST }}:${{ env.APP_NAME }} 2>/dev/null || \
          git remote set-url dokku dokku@${{ secrets.DOKKU_HOST }}:${{ env.APP_NAME }}

          # Push to deploy
          GIT_SSH_COMMAND="ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no" \
            git push dokku HEAD:refs/heads/main --force

      - name: Run release tasks
        run: |
          if [ ! -f ".dokku/config.yml" ]; then
            echo "No config.yml found, skipping release tasks"
            exit 0
          fi

          # Install yq if not already available
          which yq || sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

          # Get environment-specific tasks or fall back to global tasks
          ENV="${{ env.ENVIRONMENT }}"
          TASK_COUNT=$(yq e ".environments.${ENV}.release.tasks // .release.tasks // [] | length" .dokku/config.yml 2>/dev/null || echo "0")

          if [ "$TASK_COUNT" == "0" ] || [ -z "$TASK_COUNT" ]; then
            echo "No release tasks defined, skipping"
            exit 0
          fi

          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  Running $TASK_COUNT release task(s)..."
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          FAILED=0
          for i in $(seq 0 $((TASK_COUNT - 1))); do
            # Get task details (environment-specific or global)
            TASK_NAME=$(yq e ".environments.${ENV}.release.tasks[$i].name // .release.tasks[$i].name" .dokku/config.yml 2>/dev/null)
            TASK_CMD=$(yq e ".environments.${ENV}.release.tasks[$i].command // .release.tasks[$i].command" .dokku/config.yml 2>/dev/null)
            TASK_TIMEOUT=$(yq e ".environments.${ENV}.release.tasks[$i].timeout // .release.tasks[$i].timeout // 120" .dokku/config.yml 2>/dev/null)

            if [ -z "$TASK_CMD" ] || [ "$TASK_CMD" == "null" ]; then
              continue
            fi

            echo ""
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            echo "  Task $((i + 1))/$TASK_COUNT: $TASK_NAME"
            echo "  Command: $TASK_CMD"
            echo "  Timeout: ${TASK_TIMEOUT}s"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

            if timeout "$TASK_TIMEOUT" ssh dokku run ${{ env.APP_NAME }} $TASK_CMD; then
              echo "âœ… SUCCESS: $TASK_NAME"
            else
              echo "âŒ FAILED: $TASK_NAME"
              FAILED=1
              break
            fi
          done

          if [ "$FAILED" -eq 1 ]; then
            echo ""
            echo "::error::Release task failed: $TASK_NAME"
            exit 1
          fi

          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  All release tasks completed successfully!"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

      - name: Configure custom domains
        run: |
          if [ -f ".dokku/config.yml" ]; then
            # Check for custom_domains in config
            CUSTOM_DOMAINS=$(yq e '.custom_domains[]' .dokku/config.yml 2>/dev/null || echo "")

            # Also check environment-specific domains
            ENV_DOMAINS=$(yq e ".environments.${{ env.ENVIRONMENT }}.custom_domains[]" .dokku/config.yml 2>/dev/null || echo "")

            # Combine both lists
            ALL_DOMAINS=$(echo -e "$CUSTOM_DOMAINS\n$ENV_DOMAINS" | grep -v '^$' | sort -u)

            if [ -n "$ALL_DOMAINS" ]; then
              echo ""
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo "  Configuring Custom Domains"
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

              for DOMAIN in $ALL_DOMAINS; do
                echo "  Adding domain: $DOMAIN"
                ssh dokku domains:add ${{ env.APP_NAME }} "$DOMAIN" 2>/dev/null || \
                  echo "  (domain already configured)"
              done

              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            fi
          fi

      - name: Enable SSL
        timeout-minutes: 3
        run: |
          # Enable SSL - must be done before health check
          if ssh dokku letsencrypt:active ${{ env.APP_NAME }} 2>/dev/null; then
            echo "SSL already active"
          else
            echo "Enabling Let's Encrypt SSL..."
            if timeout 90 ssh dokku letsencrypt:enable ${{ env.APP_NAME }}; then
              echo "âœ… SSL enabled successfully"
            else
              echo "::error::SSL setup failed"
              echo "This may be due to:"
              echo "  - DNS not propagated yet for ${{ env.DOMAIN }}"
              echo "  - Let's Encrypt rate limiting"
              echo "  - Port 80 not accessible for ACME challenge"
              exit 1
            fi
          fi

      - name: Verify deployment
        run: |
          HEALTH_PATH="${{ inputs.health_check_path }}"
          [ -z "$HEALTH_PATH" ] && HEALTH_PATH="/health"

          # Always use HTTPS - SSL is now configured
          HEALTH_URL="https://${{ env.DOMAIN }}${HEALTH_PATH}"
          echo "Verifying deployment via HTTPS..."

          MAX_ATTEMPTS=6
          ATTEMPT=1
          WAIT_TIME=5

          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "Health check attempt $ATTEMPT/$MAX_ATTEMPTS (waiting ${WAIT_TIME}s)..."
            sleep $WAIT_TIME

            HTTP_STATUS=$(curl -sL -o /dev/null -w "%{http_code}" "$HEALTH_URL" --max-time 10 2>/dev/null || echo "000")

            if [ "$HTTP_STATUS" == "200" ]; then
              echo "âœ… Health check passed (HTTP $HTTP_STATUS)"
              break
            elif [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 400 ]; then
              echo "âœ… App is responding (HTTP $HTTP_STATUS)"
              break
            else
              echo "âš ï¸ Health check returned HTTP $HTTP_STATUS"
              if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
                echo ""
                echo "Health check failed after $MAX_ATTEMPTS attempts"
                echo "Recent logs:"
                ssh dokku logs ${{ env.APP_NAME }} --num 30
                exit 1
              fi
              ATTEMPT=$((ATTEMPT + 1))
              WAIT_TIME=$((WAIT_TIME + 5))
            fi
          done

          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  âœ… Deployment successful!"
          echo "  ğŸŒ https://${{ env.DOMAIN }}"
          # Show custom domains if configured
          ssh dokku domains:report ${{ env.APP_NAME }} --domains-app-vhosts 2>/dev/null | grep -v "${{ env.DOMAIN }}" | while read domain; do
            [ -n "$domain" ] && echo "  ğŸŒ https://$domain"
          done || true
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

      - name: Capture deploy info
        id: deploy_info
        run: |
          # Calculate duration
          END_TIME=$(date +%s)
          START_TIME="${{ steps.timing.outputs.start_time }}"
          DURATION=$((END_TIME - START_TIME))
          MINUTES=$((DURATION / 60))
          SECONDS=$((DURATION % 60))
          echo "duration=${MINUTES}m ${SECONDS}s" >> $GITHUB_OUTPUT

          # Commit message (first line, truncated to 100 chars)
          COMMIT_MSG=$(git log -1 --pretty=%s | head -c 100)
          echo "commit_message=$COMMIT_MSG" >> $GITHUB_OUTPUT

          # Files changed count (compared to parent commit)
          FILES_CHANGED=$(git diff --name-only HEAD~1 2>/dev/null | wc -l | tr -d ' ') || FILES_CHANGED="N/A"
          echo "files_changed=$FILES_CHANGED" >> $GITHUB_OUTPUT

          # Previous version (from Dokku config)
          PREV_VERSION=$(ssh dokku config:get ${{ env.APP_NAME }} GIT_REV 2>/dev/null || echo "none")
          echo "previous_version=${PREV_VERSION:0:7}" >> $GITHUB_OUTPUT

          # Current version
          echo "current_version=${GITHUB_SHA:0:7}" >> $GITHUB_OUTPUT

          echo "Deploy info captured:"
          echo "  Duration: ${MINUTES}m ${SECONDS}s"
          echo "  Commit: $COMMIT_MSG"
          echo "  Files changed: $FILES_CHANGED"
          echo "  Version: ${PREV_VERSION:0:7} -> ${GITHUB_SHA:0:7}"

      - name: Track release
        run: |
          echo "Recording release..."

          # Get current release number and increment
          CURRENT_RELEASE=$(ssh dokku config:get ${{ env.APP_NAME }} RELEASE_VERSION 2>/dev/null || echo "0")
          NEW_RELEASE=$((CURRENT_RELEASE + 1))

          # Get commit message (escape quotes for JSON)
          COMMIT_MSG=$(git log -1 --pretty=%s | head -c 80 | sed 's/"/\\"/g')

          # Create release record
          RELEASE_RECORD=$(jq -n \
            --arg v "$NEW_RELEASE" \
            --arg sha "${{ github.sha }}" \
            --arg short "${GITHUB_SHA:0:7}" \
            --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --arg actor "${{ github.actor }}" \
            --arg msg "$COMMIT_MSG" \
            --arg env "${{ env.ENVIRONMENT }}" \
            '{version: ($v|tonumber), sha: $sha, short: $short, timestamp: $ts, actor: $actor, message: $msg, environment: $env}')

          # Get existing release history (or empty array)
          RELEASE_HISTORY=$(ssh dokku config:get ${{ env.APP_NAME }} RELEASE_HISTORY 2>/dev/null || echo "[]")

          # Validate JSON, reset if corrupted
          if ! echo "$RELEASE_HISTORY" | jq . >/dev/null 2>&1; then
            RELEASE_HISTORY="[]"
          fi

          # Prepend new release, keep only last 10
          NEW_HISTORY=$(echo "$RELEASE_HISTORY" | jq --argjson new "$RELEASE_RECORD" '[$new] + . | .[0:10]')

          # Store release info (use base64 to handle special chars in JSON)
          HISTORY_B64=$(echo "$NEW_HISTORY" | base64 -w0)

          ssh dokku config:set --no-restart ${{ env.APP_NAME }} \
            RELEASE_VERSION="$NEW_RELEASE" \
            RELEASE_SHA="${{ github.sha }}" \
            RELEASE_TIMESTAMP="$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            RELEASE_ACTOR="${{ github.actor }}" \
            RELEASE_HISTORY_B64="$HISTORY_B64"

          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  ğŸ“¦ Release v$NEW_RELEASE created"
          echo "  Commit: ${GITHUB_SHA:0:7}"
          echo "  Actor: ${{ github.actor }}"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

      - name: Create GitHub deployment and set success status
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_ORG_TOKEN || github.token }}
          script: |
            try {
              // Create GitHub deployment
              const deployment = await github.rest.repos.createDeployment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: context.sha,
                environment: '${{ env.ENVIRONMENT }}',
                auto_merge: false,
                required_contexts: []
              });

              await github.rest.repos.createDeploymentStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: deployment.data.id,
                state: 'success',
                environment_url: 'https://${{ env.DOMAIN }}',
                description: 'Deployed successfully'
              });
            } catch (e) {
              console.log('Could not create deployment:', e.message);
            }

            try {
              // Set success commit status
              await github.rest.repos.createCommitStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                sha: context.sha,
                state: 'success',
                context: 'deploy/${{ env.ENVIRONMENT }}',
                description: 'Deployed to https://${{ env.DOMAIN }}',
                target_url: 'https://${{ env.DOMAIN }}'
              });
            } catch (e) {
              console.log('Could not set commit status:', e.message);
            }

      - name: Set failure commit status
        if: failure()
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_ORG_TOKEN || github.token }}
          script: |
            try {
              await github.rest.repos.createCommitStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                sha: context.sha,
                state: 'failure',
                context: 'deploy/${{ env.ENVIRONMENT }}',
                description: 'Deployment failed',
                target_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
              });
            } catch (e) {
              console.log('Could not set failure commit status:', e.message);
            }

      - name: Comment on associated PRs
        if: success()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_ORG_TOKEN || github.token }}
          script: |
            // Find PRs associated with this commit
            const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha
            });

            const domain = '${{ env.DOMAIN }}';
            const environment = '${{ env.ENVIRONMENT }}';
            const duration = '${{ steps.deploy_info.outputs.duration }}';

            for (const pr of prs) {
              // Only comment on merged PRs (this commit came from a merge)
              if (pr.merged_at) {
                const body = `## ğŸš€ Deployed to ${environment}

            | Status | URL |
            |--------|-----|
            | âœ… Deployed | [https://${domain}](https://${domain}) |

            **Commit:** \`${context.sha.substring(0, 7)}\`
            **Duration:** ${duration}
            **Environment:** ${environment}

            ---
            <sub>Deployed via [workflow run](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})</sub>`;

                // Check if we already commented
                const { data: comments } = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number
                });

                const existingComment = comments.find(c =>
                  c.user.type === 'Bot' &&
                  c.body.includes(`Deployed to ${environment}`)
                );

                if (existingComment) {
                  await github.rest.issues.updateComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: existingComment.id,
                    body: body
                  });
                } else {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: pr.number,
                    body: body
                  });
                }
              }
            }

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Notify - Send deployment notifications
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [setup, deploy]
    if: always()

    env:
      APP_NAME: ${{ needs.setup.outputs.app_name }}
      ENVIRONMENT: ${{ needs.setup.outputs.environment }}
      DOMAIN: ${{ needs.setup.outputs.app_name }}.${{ vars.BASE_DOMAIN }}

    steps:
      - name: Notify Slack
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          [ -z "$SLACK_WEBHOOK_URL" ] && exit 0
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            COLOR="good"
            STATUS="âœ… Deployed successfully"
          else
            COLOR="danger"
            STATUS="âŒ Deployment failed"
          fi

          # Get deploy info from outputs
          DURATION="${{ needs.deploy.outputs.duration }}"
          FILES_CHANGED="${{ needs.deploy.outputs.files_changed }}"
          PREV_VERSION="${{ needs.deploy.outputs.previous_version }}"
          CURR_VERSION="${{ needs.deploy.outputs.current_version }}"
          COMMIT_MSG="${{ needs.deploy.outputs.commit_message }}"

          # Build version string
          if [ "$PREV_VERSION" != "none" ] && [ -n "$PREV_VERSION" ]; then
            VERSION_STR="${PREV_VERSION} â†’ ${CURR_VERSION}"
          else
            VERSION_STR="${CURR_VERSION} (first deploy)"
          fi

          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"attachments\": [{
                \"color\": \"$COLOR\",
                \"title\": \"$STATUS\",
                \"fields\": [
                  {\"title\": \"App\", \"value\": \"${{ env.APP_NAME }}\", \"short\": true},
                  {\"title\": \"Environment\", \"value\": \"${{ env.ENVIRONMENT }}\", \"short\": true},
                  {\"title\": \"Duration\", \"value\": \"$DURATION\", \"short\": true},
                  {\"title\": \"Files Changed\", \"value\": \"$FILES_CHANGED\", \"short\": true},
                  {\"title\": \"Version\", \"value\": \"$VERSION_STR\", \"short\": true},
                  {\"title\": \"Actor\", \"value\": \"${{ github.actor }}\", \"short\": true},
                  {\"title\": \"Commit\", \"value\": \"$COMMIT_MSG\", \"short\": false},
                  {\"title\": \"URL\", \"value\": \"https://${{ env.DOMAIN }}\", \"short\": false}
                ],
                \"footer\": \"<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Workflow> | <${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}|View Commit>\"
              }]
            }" \
            "$SLACK_WEBHOOK_URL" || true

      - name: Notify Discord
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          [ -z "$DISCORD_WEBHOOK_URL" ] && exit 0
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            COLOR=3066993
            TITLE="âœ… Deployment Successful"
          else
            COLOR=15158332
            TITLE="âŒ Deployment Failed"
          fi

          curl -H "Content-Type: application/json" \
            -d "{
              \"embeds\": [{
                \"title\": \"$TITLE\",
                \"color\": $COLOR,
                \"fields\": [
                  {\"name\": \"App\", \"value\": \"${{ env.APP_NAME }}\", \"inline\": true},
                  {\"name\": \"Environment\", \"value\": \"${{ env.ENVIRONMENT }}\", \"inline\": true},
                  {\"name\": \"Branch\", \"value\": \"${{ github.ref_name }}\", \"inline\": true},
                  {\"name\": \"URL\", \"value\": \"https://${{ env.DOMAIN }}\", \"inline\": false}
                ],
                \"footer\": {\"text\": \"Deployed by ${{ github.actor }}\"},
                \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
              }]
            }" \
            "$DISCORD_WEBHOOK_URL" || true

      - name: Send custom webhook notifications
        if: always()
        env:
          WEBHOOK_URLS: ${{ secrets.DEPLOY_WEBHOOK_URLS }}
          WEBHOOK_SECRET: ${{ secrets.DEPLOY_WEBHOOK_SECRET }}
        run: |
          [ -z "$WEBHOOK_URLS" ] && exit 0

          # Build payload
          PAYLOAD=$(jq -n \
            --arg event "deployment" \
            --arg app "${{ env.APP_NAME }}" \
            --arg env "${{ env.ENVIRONMENT }}" \
            --arg status "${{ needs.deploy.result }}" \
            --arg sha "${{ github.sha }}" \
            --arg sha_short "${GITHUB_SHA:0:7}" \
            --arg actor "${{ github.actor }}" \
            --arg branch "${{ github.ref_name }}" \
            --arg url "https://${{ env.DOMAIN }}" \
            --arg workflow_url "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            --arg repo "${{ github.repository }}" \
            '{
              event: $event,
              app: $app,
              environment: $env,
              status: $status,
              commit_sha: $sha,
              commit_sha_short: $sha_short,
              deployed_by: $actor,
              branch: $branch,
              app_url: $url,
              workflow_url: $workflow_url,
              repository: $repo,
              timestamp: (now | todate)
            }')

          # Send to each webhook URL (comma-separated)
          IFS=',' read -ra URLS <<< "$WEBHOOK_URLS"
          for URL in "${URLS[@]}"; do
            URL=$(echo "$URL" | xargs)  # Trim whitespace
            [ -z "$URL" ] && continue

            # Calculate HMAC signature if secret is set
            if [ -n "$WEBHOOK_SECRET" ]; then
              SIGNATURE=$(echo -n "$PAYLOAD" | openssl dgst -sha256 -hmac "$WEBHOOK_SECRET" | awk '{print $2}')
              SIGNATURE_HEADER="-H \"X-Deploy-Signature: sha256=$SIGNATURE\""
            else
              SIGNATURE_HEADER=""
            fi

            echo "Sending webhook to: ${URL:0:50}..."
            curl -s -X POST "$URL" \
              -H "Content-Type: application/json" \
              -H "X-Deploy-Event: deployment" \
              $SIGNATURE_HEADER \
              -d "$PAYLOAD" || echo "Failed to send to $URL"
          done

      - name: Notify Datadog
        if: always()
        env:
          DD_API_KEY: ${{ secrets.DD_API_KEY }}
        run: |
          [ -z "$DD_API_KEY" ] && exit 0

          if [ "${{ needs.deploy.result }}" == "success" ]; then
            ALERT_TYPE="info"
            TITLE="âœ… Deployed: ${{ env.APP_NAME }} to ${{ env.ENVIRONMENT }}"
          else
            ALERT_TYPE="error"
            TITLE="âŒ Deploy Failed: ${{ env.APP_NAME }} to ${{ env.ENVIRONMENT }}"
          fi

          curl -s -X POST "https://api.datadoghq.com/api/v1/events" \
            -H "DD-API-KEY: $DD_API_KEY" \
            -H "Content-Type: application/json" \
            -d "{
              \"title\": \"$TITLE\",
              \"text\": \"Deployed ${GITHUB_SHA:0:7} by ${{ github.actor }}\nURL: https://${{ env.DOMAIN }}\",
              \"tags\": [\"app:${{ env.APP_NAME }}\", \"env:${{ env.ENVIRONMENT }}\", \"deploy\", \"status:${{ needs.deploy.result }}\"],
              \"alert_type\": \"$ALERT_TYPE\",
              \"source_type_name\": \"github\"
            }" || true

      - name: Notify PagerDuty (on failure)
        if: failure() || needs.deploy.result == 'failure'
        env:
          PD_ROUTING_KEY: ${{ secrets.PAGERDUTY_ROUTING_KEY }}
        run: |
          [ -z "$PD_ROUTING_KEY" ] && exit 0

          curl -s -X POST "https://events.pagerduty.com/v2/enqueue" \
            -H "Content-Type: application/json" \
            -d "{
              \"routing_key\": \"$PD_ROUTING_KEY\",
              \"event_action\": \"trigger\",
              \"dedup_key\": \"deploy-${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}-${{ github.run_id }}\",
              \"payload\": {
                \"summary\": \"Deployment failed: ${{ env.APP_NAME }} to ${{ env.ENVIRONMENT }}\",
                \"severity\": \"error\",
                \"source\": \"dokku-deploy\",
                \"custom_details\": {
                  \"app\": \"${{ env.APP_NAME }}\",
                  \"environment\": \"${{ env.ENVIRONMENT }}\",
                  \"commit\": \"${GITHUB_SHA:0:7}\",
                  \"actor\": \"${{ github.actor }}\",
                  \"branch\": \"${{ github.ref_name }}\"
                }
              },
              \"links\": [{
                \"href\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\",
                \"text\": \"View Workflow\"
              }]
            }" || true

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Update Dashboard - Update the deployment dashboard
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  update-dashboard:
    name: Update Dashboard
    needs: [setup, deploy]
    if: always()
    uses: ./.github/workflows/update-dashboard.yml
    with:
      app_name: ${{ needs.setup.outputs.app_name }}
      action: deploy
      status: ${{ needs.deploy.result }}
      environment: ${{ needs.setup.outputs.environment }}
      url: ${{ needs.setup.outputs.app_url }}
      commit_sha: ${{ github.sha }}
      actor: ${{ github.actor }}
    secrets: inherit

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Audit Log - Record deployment in audit log
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  audit-log:
    name: Audit Log
    needs: [setup, deploy]
    if: always()
    uses: ./.github/workflows/audit-log.yml
    with:
      action: deploy
      app_name: ${{ needs.setup.outputs.app_name }}
      environment: ${{ needs.setup.outputs.environment }}
      status: ${{ needs.deploy.result }}
      commit_sha: ${{ github.sha }}
      commit_message: ${{ needs.deploy.outputs.commit_message }}
      duration: ${{ needs.deploy.outputs.duration }}
      url: ${{ needs.setup.outputs.app_url }}
    secrets: inherit
