# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# preview.yml - Reusable Pull Request Preview Environments
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# REUSABLE WORKFLOW - Called by other repos via:
#   uses: signalwire-demos/dokku-deploy-system/.github/workflows/preview.yml@main
#
# Creates temporary preview environments for pull requests.
# Automatically deploys when a PR is opened/updated and destroys when closed.
#
# SECURITY:
#   - Auto-deploy: Only for org members (prevents malicious fork PRs)
#   - External PRs: Org members can manually trigger via workflow_dispatch
#   - Cleanup: Always runs on PR close (regardless of author)
#
# Required Secrets (set at org level):
#   - DOKKU_HOST: Dokku server hostname
#   - DOKKU_SSH_PRIVATE_KEY: SSH private key for deployment
#   - BASE_DOMAIN: Base domain for apps (e.g., yourdomain.com)
#   - GH_ORG_TOKEN: PAT with read:org scope (for membership check)
#
# Optional Secrets:
#   - PREVIEW_AUTH_USER: HTTP auth username for previews
#   - PREVIEW_AUTH_PASSWORD: HTTP auth password for previews
#   - SLACK_WEBHOOK_URL: Slack notifications
#   - DISCORD_WEBHOOK_URL: Discord notifications
#
# Preview URL format: {app-name}-pr-{pr-number}.{base-domain}
#
# Manual trigger for external PRs (run from this repo's Actions tab):
#   Select "Preview Environment" â†’ Run workflow â†’ Enter repo and PR number
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: Preview Environment

on:
  # Manual trigger for external contributor PRs (org members only)
  workflow_dispatch:
    inputs:
      repo:
        description: 'Repository (e.g., signalwire-demos/my-app)'
        required: true
        type: string
      pr_number:
        description: 'Pull request number'
        required: true
        type: string
      action:
        description: 'Action to perform'
        required: true
        type: choice
        options:
          - deploy
          - destroy
        default: deploy

  # Called by other repos via workflow_call
  workflow_call:
    inputs:
      memory_limit:
        description: 'Memory limit for preview apps'
        required: false
        type: string
        default: '256m'
      cpu_limit:
        description: 'CPU limit for preview apps'
        required: false
        type: string
        default: '0.5'
    secrets:
      DOKKU_HOST:
        required: true
      DOKKU_SSH_PRIVATE_KEY:
        required: true
      BASE_DOMAIN:
        required: true
      GH_ORG_TOKEN:
        required: false
      PREVIEW_AUTH_USER:
        required: false
      PREVIEW_AUTH_PASSWORD:
        required: false
      SLACK_WEBHOOK_URL:
        required: false
      DISCORD_WEBHOOK_URL:
        required: false

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Setup - Determine PR info and check permissions
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  setup:
    name: Setup
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      should_cleanup: ${{ steps.check.outputs.should_cleanup }}
      app_name: ${{ steps.info.outputs.app_name }}
      base_app_name: ${{ steps.info.outputs.base_app_name }}
      pr_number: ${{ steps.info.outputs.pr_number }}
      repo: ${{ steps.info.outputs.repo }}
      pr_author: ${{ steps.info.outputs.pr_author }}
      head_sha: ${{ steps.info.outputs.head_sha }}
      head_ref: ${{ steps.info.outputs.head_ref }}
      is_manual: ${{ steps.info.outputs.is_manual }}

    steps:
      - name: Determine PR info
        id: info
        env:
          GH_TOKEN: ${{ secrets.GH_ORG_TOKEN || github.token }}
        run: |
          # Check if this is a manual trigger (workflow_dispatch)
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "is_manual=true" >> $GITHUB_OUTPUT
            REPO="${{ github.event.inputs.repo }}"
            PR_NUMBER="${{ github.event.inputs.pr_number }}"

            # Fetch PR info from the specified repo
            PR_INFO=$(gh api repos/${REPO}/pulls/${PR_NUMBER})
            PR_AUTHOR=$(echo "$PR_INFO" | jq -r '.user.login')
            HEAD_SHA=$(echo "$PR_INFO" | jq -r '.head.sha')
            HEAD_REF=$(echo "$PR_INFO" | jq -r '.head.ref')
            BASE_APP_NAME=$(echo "$REPO" | cut -d'/' -f2)
          else
            echo "is_manual=false" >> $GITHUB_OUTPUT
            REPO="${{ github.repository }}"
            PR_NUMBER="${{ github.event.pull_request.number }}"
            PR_AUTHOR="${{ github.event.pull_request.user.login }}"
            HEAD_SHA="${{ github.event.pull_request.head.sha }}"
            HEAD_REF="${{ github.event.pull_request.head.ref }}"
            BASE_APP_NAME="${{ github.event.repository.name }}"
          fi

          APP_NAME="${BASE_APP_NAME}-pr-${PR_NUMBER}"

          echo "repo=${REPO}" >> $GITHUB_OUTPUT
          echo "pr_number=${PR_NUMBER}" >> $GITHUB_OUTPUT
          echo "pr_author=${PR_AUTHOR}" >> $GITHUB_OUTPUT
          echo "head_sha=${HEAD_SHA}" >> $GITHUB_OUTPUT
          echo "head_ref=${HEAD_REF}" >> $GITHUB_OUTPUT
          echo "base_app_name=${BASE_APP_NAME}" >> $GITHUB_OUTPUT
          echo "app_name=${APP_NAME}" >> $GITHUB_OUTPUT

          echo "PR Info:"
          echo "  Repo: ${REPO}"
          echo "  PR #: ${PR_NUMBER}"
          echo "  Author: ${PR_AUTHOR}"
          echo "  App: ${APP_NAME}"

      - name: Check org membership and permissions
        id: check
        env:
          GH_TOKEN: ${{ secrets.GH_ORG_TOKEN || github.token }}
        run: |
          PR_AUTHOR="${{ steps.info.outputs.pr_author }}"
          ORG="${{ github.repository_owner }}"
          IS_MANUAL="${{ steps.info.outputs.is_manual }}"
          EVENT_ACTION="${{ github.event.action }}"
          DISPATCH_ACTION="${{ github.event.inputs.action }}"

          # Determine if this is a cleanup operation
          if [ "$EVENT_ACTION" == "closed" ] || [ "$DISPATCH_ACTION" == "destroy" ]; then
            echo "should_cleanup=true" >> $GITHUB_OUTPUT
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "Action: Cleanup"
            exit 0
          fi

          echo "should_cleanup=false" >> $GITHUB_OUTPUT

          # Manual triggers are always allowed (only org members can trigger)
          if [ "$IS_MANUAL" == "true" ]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "Manual trigger by org member - deploying"
            exit 0
          fi

          # Check if PR author is an org member
          echo "Checking if ${PR_AUTHOR} is a member of ${ORG}..."

          if gh api orgs/${ORG}/members/${PR_AUTHOR} --silent 2>/dev/null; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "âœ… ${PR_AUTHOR} is an org member - auto-deploying"
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ ${PR_AUTHOR} is not an org member - skipping auto-deploy"
            echo "   An org member can manually trigger the preview from:"
            echo "   https://github.com/${{ github.repository }}/actions/workflows/preview.yml"
          fi

      - name: Comment on PR (external contributor)
        if: steps.check.outputs.should_deploy == 'false' && steps.check.outputs.should_cleanup == 'false'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          REPO="${{ steps.info.outputs.repo }}"
          PR_NUMBER="${{ steps.info.outputs.pr_number }}"
          PR_AUTHOR="${{ steps.info.outputs.pr_author }}"

          # Check if we already commented
          EXISTING=$(gh api repos/${REPO}/issues/${PR_NUMBER}/comments \
            --jq '.[] | select(.body | contains("Preview deployment requires approval"))' 2>/dev/null || echo "")

          if [ -z "$EXISTING" ]; then
            gh api repos/${REPO}/issues/${PR_NUMBER}/comments \
              -f body="## ğŸ”’ Preview Deployment Requires Approval

          Hi @${PR_AUTHOR}! Since you're not a member of this organization, preview deployments require manual approval from a maintainer.

          **Maintainers:** To deploy a preview for this PR, go to:
          [Actions â†’ Preview Environment â†’ Run workflow](https://github.com/${{ github.repository }}/actions/workflows/preview.yml)

          Enter:
          - Repository: \`${REPO}\`
          - PR number: \`${PR_NUMBER}\`
          - Action: \`deploy\`"
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Deploy Preview
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  deploy-preview:
    name: Deploy Preview
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.should_deploy == 'true'
    environment: preview

    env:
      APP_NAME: ${{ needs.setup.outputs.app_name }}
      BASE_APP_NAME: ${{ needs.setup.outputs.base_app_name }}
      PR_NUMBER: ${{ needs.setup.outputs.pr_number }}
      TARGET_REPO: ${{ needs.setup.outputs.repo }}
      HEAD_SHA: ${{ needs.setup.outputs.head_sha }}
      HEAD_REF: ${{ needs.setup.outputs.head_ref }}

    steps:
      - name: Set pending commit status
        uses: actions/github-script@v7
        env:
          TARGET_REPO: ${{ needs.setup.outputs.repo }}
          HEAD_SHA: ${{ needs.setup.outputs.head_sha }}
        with:
          github-token: ${{ secrets.GH_ORG_TOKEN || github.token }}
          script: |
            const [owner, repo] = process.env.TARGET_REPO.split('/');
            await github.rest.repos.createCommitStatus({
              owner,
              repo,
              sha: process.env.HEAD_SHA,
              state: 'pending',
              context: 'preview/deploy',
              description: 'Preview deployment in progress...',
              target_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            });

      - name: Create preview environment if needed
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh api repos/${{ env.TARGET_REPO }}/environments/preview -X PUT 2>/dev/null || true

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          repository: ${{ env.TARGET_REPO }}
          ref: ${{ env.HEAD_SHA }}
          fetch-depth: 0

      - name: Setup SSH connection
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          echo "${{ secrets.DOKKU_SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          ssh-keyscan -H ${{ secrets.DOKKU_HOST }} >> ~/.ssh/known_hosts 2>/dev/null

          cat >> ~/.ssh/config << EOF
          Host dokku
            HostName ${{ secrets.DOKKU_HOST }}
            User dokku
            IdentityFile ~/.ssh/deploy_key
            StrictHostKeyChecking no
          EOF
          chmod 600 ~/.ssh/config

      - name: Check deploy lock on base app
        run: |
          # Check if base app (production) is locked - if so, block preview deploys too
          BASE_APP="${{ env.BASE_APP_NAME }}"
          if ssh dokku apps:exists "$BASE_APP" 2>/dev/null; then
            LOCKED=$(ssh dokku config:get "$BASE_APP" DEPLOY_LOCKED 2>/dev/null || echo "false")
            if [ "$LOCKED" == "true" ]; then
              REASON=$(ssh dokku config:get "$BASE_APP" DEPLOY_LOCK_REASON 2>/dev/null || echo "No reason provided")
              LOCKED_BY=$(ssh dokku config:get "$BASE_APP" DEPLOY_LOCK_BY 2>/dev/null || echo "Unknown")
              echo ""
              echo "::error::Preview deployment blocked - Base app is locked!"
              echo ""
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo "  DEPLOY LOCK ACTIVE on $BASE_APP"
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo "  Reason: $REASON"
              echo "  Locked by: $LOCKED_BY"
              echo ""
              echo "  Preview deploys are blocked when the base app is locked."
              echo "  To unlock, run the Deploy Lock workflow on the base app."
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              exit 1
            fi
          fi
          echo "Deploy lock check passed"

      - name: Create preview app
        run: |
          echo "Creating preview app: ${{ env.APP_NAME }}"
          ssh dokku apps:exists ${{ env.APP_NAME }} 2>/dev/null || \
          ssh dokku apps:create ${{ env.APP_NAME }}

      - name: Provision shared services
        run: |
          if [ -f ".dokku/services.yml" ]; then
            # Install yq
            sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
            sudo chmod +x /usr/local/bin/yq

            # PostgreSQL - use shared preview database
            if yq e '.services.postgres.enabled' .dokku/services.yml 2>/dev/null | grep -q "true"; then
              SHARED=$(yq e '.services.postgres.environments.preview.shared // false' .dokku/services.yml)
              if [ "$SHARED" == "true" ]; then
                DB_NAME="postgres-preview-shared"
              else
                DB_NAME="postgres-${{ env.APP_NAME }}"
              fi
              echo "Provisioning PostgreSQL: $DB_NAME"
              ssh dokku postgres:exists $DB_NAME 2>/dev/null || ssh dokku postgres:create $DB_NAME
              ssh dokku postgres:link $DB_NAME ${{ env.APP_NAME }} 2>/dev/null || true
            fi

            # Redis - use shared preview instance
            if yq e '.services.redis.enabled' .dokku/services.yml 2>/dev/null | grep -q "true"; then
              SHARED=$(yq e '.services.redis.environments.preview.shared // false' .dokku/services.yml)
              if [ "$SHARED" == "true" ]; then
                REDIS_NAME="redis-preview-shared"
              else
                REDIS_NAME="redis-${{ env.APP_NAME }}"
              fi
              echo "Provisioning Redis: $REDIS_NAME"
              ssh dokku redis:exists $REDIS_NAME 2>/dev/null || ssh dokku redis:create $REDIS_NAME
              ssh dokku redis:link $REDIS_NAME ${{ env.APP_NAME }} 2>/dev/null || true
            fi

            # MongoDB
            if yq e '.services.mongo.enabled' .dokku/services.yml 2>/dev/null | grep -q "true"; then
              PREVIEW_ENABLED=$(yq e '.services.mongo.environments.preview.enabled // true' .dokku/services.yml)
              if [ "$PREVIEW_ENABLED" != "false" ]; then
                SHARED=$(yq e '.services.mongo.environments.preview.shared // false' .dokku/services.yml)
                if [ "$SHARED" == "true" ]; then
                  MONGO_NAME="mongo-preview-shared"
                else
                  MONGO_NAME="mongo-${{ env.APP_NAME }}"
                fi
                echo "Provisioning MongoDB: $MONGO_NAME"
                ssh dokku mongo:exists $MONGO_NAME 2>/dev/null || ssh dokku mongo:create $MONGO_NAME
                ssh dokku mongo:link $MONGO_NAME ${{ env.APP_NAME }} 2>/dev/null || true
              fi
            fi

            # MySQL
            if yq e '.services.mysql.enabled' .dokku/services.yml 2>/dev/null | grep -q "true"; then
              PREVIEW_ENABLED=$(yq e '.services.mysql.environments.preview.enabled // true' .dokku/services.yml)
              if [ "$PREVIEW_ENABLED" != "false" ]; then
                SHARED=$(yq e '.services.mysql.environments.preview.shared // false' .dokku/services.yml)
                if [ "$SHARED" == "true" ]; then
                  MYSQL_NAME="mysql-preview-shared"
                else
                  MYSQL_NAME="mysql-${{ env.APP_NAME }}"
                fi
                echo "Provisioning MySQL: $MYSQL_NAME"
                ssh dokku mysql:exists $MYSQL_NAME 2>/dev/null || ssh dokku mysql:create $MYSQL_NAME
                ssh dokku mysql:link $MYSQL_NAME ${{ env.APP_NAME }} 2>/dev/null || true
              fi
            fi

            # RabbitMQ
            if yq e '.services.rabbitmq.enabled' .dokku/services.yml 2>/dev/null | grep -q "true"; then
              PREVIEW_ENABLED=$(yq e '.services.rabbitmq.environments.preview.enabled // true' .dokku/services.yml)
              if [ "$PREVIEW_ENABLED" != "false" ]; then
                SHARED=$(yq e '.services.rabbitmq.environments.preview.shared // false' .dokku/services.yml)
                if [ "$SHARED" == "true" ]; then
                  RABBITMQ_NAME="rabbitmq-preview-shared"
                else
                  RABBITMQ_NAME="rabbitmq-${{ env.APP_NAME }}"
                fi
                echo "Provisioning RabbitMQ: $RABBITMQ_NAME"
                ssh dokku rabbitmq:exists $RABBITMQ_NAME 2>/dev/null || ssh dokku rabbitmq:create $RABBITMQ_NAME
                ssh dokku rabbitmq:link $RABBITMQ_NAME ${{ env.APP_NAME }} 2>/dev/null || true
              fi
            fi

            # Elasticsearch
            if yq e '.services.elasticsearch.enabled' .dokku/services.yml 2>/dev/null | grep -q "true"; then
              PREVIEW_ENABLED=$(yq e '.services.elasticsearch.environments.preview.enabled // true' .dokku/services.yml)
              if [ "$PREVIEW_ENABLED" != "false" ]; then
                SHARED=$(yq e '.services.elasticsearch.environments.preview.shared // false' .dokku/services.yml)
                if [ "$SHARED" == "true" ]; then
                  ES_NAME="elasticsearch-preview-shared"
                else
                  ES_NAME="elasticsearch-${{ env.APP_NAME }}"
                fi
                echo "Provisioning Elasticsearch: $ES_NAME"
                ssh dokku elasticsearch:exists $ES_NAME 2>/dev/null || ssh dokku elasticsearch:create $ES_NAME
                ssh dokku elasticsearch:link $ES_NAME ${{ env.APP_NAME }} 2>/dev/null || true
              fi
            fi
          fi

      - name: Configure preview environment
        env:
          ALL_VARS: ${{ toJSON(vars) }}
        run: |
          DOMAIN="${{ env.APP_NAME }}.${{ secrets.BASE_DOMAIN }}"

          echo "Configuring preview environment..."

          # Start with required vars
          CONFIG_VARS="APP_ENV=preview APP_NAME=${{ env.APP_NAME }} APP_URL=https://$DOMAIN AGENT_NAME=${{ env.APP_NAME }} PR_NUMBER=${{ env.PR_NUMBER }} GIT_REV=${{ env.HEAD_SHA }}"

          # Loop through all environment variables from GitHub environment
          for key in $(echo "$ALL_VARS" | jq -r 'keys[]'); do
            value=$(echo "$ALL_VARS" | jq -r --arg k "$key" '.[$k]')
            [ -n "$value" ] && CONFIG_VARS="$CONFIG_VARS $key=$value"
          done

          # Clear existing config and set fresh values to ensure changes are applied
          ssh dokku config:clear --no-restart ${{ env.APP_NAME }} 2>/dev/null || true
          ssh dokku config:set --no-restart ${{ env.APP_NAME }} $CONFIG_VARS

          # Configure domain
          ssh dokku domains:clear ${{ env.APP_NAME }} 2>/dev/null || true
          ssh dokku domains:add ${{ env.APP_NAME }} "$DOMAIN"

          # Set resource limits (smaller for previews)
          MEMORY="${{ inputs.memory_limit }}"
          CPU="${{ inputs.cpu_limit }}"
          [ -z "$MEMORY" ] && MEMORY="256m"
          [ -z "$CPU" ] && CPU="0.5"
          ssh dokku resource:limit ${{ env.APP_NAME }} --memory $MEMORY --cpu $CPU || true

      - name: Deploy preview
        run: |
          echo "Deploying preview..."

          git remote add dokku dokku@${{ secrets.DOKKU_HOST }}:${{ env.APP_NAME }} 2>/dev/null || \
          git remote set-url dokku dokku@${{ secrets.DOKKU_HOST }}:${{ env.APP_NAME }}

          GIT_SSH_COMMAND="ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no" \
            git push dokku HEAD:refs/heads/main --force

      - name: Run release tasks
        run: |
          if [ ! -f ".dokku/config.yml" ]; then
            echo "No config.yml found, skipping release tasks"
            exit 0
          fi

          # yq should already be installed from service provisioning
          which yq || exit 0

          # For previews, check preview-specific tasks first
          TASK_COUNT=$(yq e ".environments.preview.release.tasks // .release.tasks // [] | length" .dokku/config.yml 2>/dev/null || echo "0")

          if [ "$TASK_COUNT" == "0" ] || [ -z "$TASK_COUNT" ]; then
            echo "No release tasks defined, skipping"
            exit 0
          fi

          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  Running $TASK_COUNT release task(s)..."
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          FAILED=0
          for i in $(seq 0 $((TASK_COUNT - 1))); do
            TASK_NAME=$(yq e ".environments.preview.release.tasks[$i].name // .release.tasks[$i].name" .dokku/config.yml 2>/dev/null)
            TASK_CMD=$(yq e ".environments.preview.release.tasks[$i].command // .release.tasks[$i].command" .dokku/config.yml 2>/dev/null)
            TASK_TIMEOUT=$(yq e ".environments.preview.release.tasks[$i].timeout // .release.tasks[$i].timeout // 120" .dokku/config.yml 2>/dev/null)

            if [ -z "$TASK_CMD" ] || [ "$TASK_CMD" == "null" ]; then
              continue
            fi

            echo ""
            echo "  Task $((i + 1))/$TASK_COUNT: $TASK_NAME"
            if timeout "$TASK_TIMEOUT" ssh dokku run ${{ env.APP_NAME }} $TASK_CMD; then
              echo "  âœ… SUCCESS"
            else
              echo "  âŒ FAILED"
              FAILED=1
              break
            fi
          done

          if [ "$FAILED" -eq 1 ]; then
            echo "::error::Release task failed: $TASK_NAME"
            exit 1
          fi

          echo ""
          echo "  All release tasks completed!"

      - name: Verify deployment
        id: verify
        run: |
          DOMAIN="${{ env.APP_NAME }}.${{ secrets.BASE_DOMAIN }}"

          echo "Verifying preview via HTTP..."
          sleep 10

          # Use HTTP for health check - SSL will be enabled next
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "http://$DOMAIN/health" 2>/dev/null || echo "000")

          if [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 400 ]; then
            echo "âœ… Preview is ready!"
            echo "status=success" >> $GITHUB_OUTPUT
          else
            # Try without /health
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "http://$DOMAIN/" 2>/dev/null || echo "000")
            if [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 400 ]; then
              echo "âœ… Preview is ready!"
              echo "status=success" >> $GITHUB_OUTPUT
            else
              echo "âš ï¸ Preview returned HTTP $HTTP_STATUS"
              echo "status=warning" >> $GITHUB_OUTPUT
            fi
          fi

          echo "url=https://$DOMAIN" >> $GITHUB_OUTPUT

      - name: Enable SSL
        run: |
          echo "Enabling SSL..."
          if ssh dokku letsencrypt:active ${{ env.APP_NAME }} 2>/dev/null; then
            echo "SSL already active"
          else
            ssh dokku letsencrypt:enable ${{ env.APP_NAME }}
          fi

      - name: Add HTTP authentication (optional)
        env:
          PREVIEW_AUTH_USER: ${{ secrets.PREVIEW_AUTH_USER }}
          PREVIEW_AUTH_PASSWORD: ${{ secrets.PREVIEW_AUTH_PASSWORD }}
        run: |
          # Protect preview apps with basic auth if configured
          if [ -n "$PREVIEW_AUTH_USER" ] && [ -n "$PREVIEW_AUTH_PASSWORD" ]; then
            echo "Enabling HTTP authentication..."
            ssh dokku http-auth:enable ${{ env.APP_NAME }} \
              "$PREVIEW_AUTH_USER" \
              "$PREVIEW_AUTH_PASSWORD" || true
          fi

      - name: Comment preview URL on PR
        uses: actions/github-script@v7
        env:
          TARGET_REPO: ${{ env.TARGET_REPO }}
          PR_NUMBER: ${{ env.PR_NUMBER }}
          HEAD_SHA: ${{ env.HEAD_SHA }}
          HEAD_REF: ${{ env.HEAD_REF }}
        with:
          script: |
            const [owner, repo] = process.env.TARGET_REPO.split('/');
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            const domain = `${{ env.APP_NAME }}.${{ secrets.BASE_DOMAIN }}`;
            const url = `https://${domain}`;
            const status = '${{ steps.verify.outputs.status }}' === 'success' ? 'âœ… Deployed' : 'âš ï¸ Deployed (check logs)';

            // Find existing bot comment
            const comments = await github.rest.issues.listComments({
              owner,
              repo,
              issue_number: prNumber,
            });

            const botComment = comments.data.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('Preview Environment')
            );

            const body = `## ğŸš€ Preview Environment

            | Status | URL |
            |--------|-----|
            | ${status} | [${url}](${url}) |

            **Commit:** \`${process.env.HEAD_SHA}\`
            **Branch:** \`${process.env.HEAD_REF}\`

            ---
            <sub>This preview will be automatically destroyed when the PR is closed or merged.</sub>`;

            if (botComment) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body: body
              });
            }

      - name: Set success commit status
        uses: actions/github-script@v7
        env:
          TARGET_REPO: ${{ env.TARGET_REPO }}
          HEAD_SHA: ${{ env.HEAD_SHA }}
          APP_NAME: ${{ env.APP_NAME }}
        with:
          github-token: ${{ secrets.GH_ORG_TOKEN || github.token }}
          script: |
            const [owner, repo] = process.env.TARGET_REPO.split('/');
            const domain = `${process.env.APP_NAME}.${{ secrets.BASE_DOMAIN }}`;
            await github.rest.repos.createCommitStatus({
              owner,
              repo,
              sha: process.env.HEAD_SHA,
              state: 'success',
              context: 'preview/deploy',
              description: `Preview deployed to https://${domain}`,
              target_url: `https://${domain}`
            });

      - name: Set failure commit status
        if: failure()
        uses: actions/github-script@v7
        env:
          TARGET_REPO: ${{ env.TARGET_REPO }}
          HEAD_SHA: ${{ env.HEAD_SHA }}
        with:
          github-token: ${{ secrets.GH_ORG_TOKEN || github.token }}
          script: |
            const [owner, repo] = process.env.TARGET_REPO.split('/');
            await github.rest.repos.createCommitStatus({
              owner,
              repo,
              sha: process.env.HEAD_SHA,
              state: 'failure',
              context: 'preview/deploy',
              description: 'Preview deployment failed',
              target_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            });

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Cleanup Preview
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  cleanup-preview:
    name: Cleanup Preview
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.should_cleanup == 'true'

    env:
      APP_NAME: ${{ needs.setup.outputs.app_name }}
      TARGET_REPO: ${{ needs.setup.outputs.repo }}
      PR_NUMBER: ${{ needs.setup.outputs.pr_number }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          repository: ${{ env.TARGET_REPO }}

      - name: Setup SSH connection
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          echo "${{ secrets.DOKKU_SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          ssh-keyscan -H ${{ secrets.DOKKU_HOST }} >> ~/.ssh/known_hosts 2>/dev/null

      - name: Cleanup preview services
        run: |
          if [ -f ".dokku/services.yml" ]; then
            # Install yq
            sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
            sudo chmod +x /usr/local/bin/yq

            # Only destroy non-shared services
            # PostgreSQL
            SHARED=$(yq e '.services.postgres.environments.preview.shared // false' .dokku/services.yml 2>/dev/null)
            if [ "$SHARED" != "true" ]; then
              DB_NAME="postgres-${{ env.APP_NAME }}"
              echo "Destroying PostgreSQL: $DB_NAME"
              ssh -i ~/.ssh/deploy_key dokku@${{ secrets.DOKKU_HOST }} \
                postgres:destroy $DB_NAME --force 2>/dev/null || true
            fi

            # Redis
            SHARED=$(yq e '.services.redis.environments.preview.shared // false' .dokku/services.yml 2>/dev/null)
            if [ "$SHARED" != "true" ]; then
              REDIS_NAME="redis-${{ env.APP_NAME }}"
              echo "Destroying Redis: $REDIS_NAME"
              ssh -i ~/.ssh/deploy_key dokku@${{ secrets.DOKKU_HOST }} \
                redis:destroy $REDIS_NAME --force 2>/dev/null || true
            fi

            # MongoDB
            SHARED=$(yq e '.services.mongo.environments.preview.shared // false' .dokku/services.yml 2>/dev/null)
            if [ "$SHARED" != "true" ]; then
              MONGO_NAME="mongo-${{ env.APP_NAME }}"
              echo "Destroying MongoDB: $MONGO_NAME"
              ssh -i ~/.ssh/deploy_key dokku@${{ secrets.DOKKU_HOST }} \
                mongo:destroy $MONGO_NAME --force 2>/dev/null || true
            fi

            # MySQL
            SHARED=$(yq e '.services.mysql.environments.preview.shared // false' .dokku/services.yml 2>/dev/null)
            if [ "$SHARED" != "true" ]; then
              MYSQL_NAME="mysql-${{ env.APP_NAME }}"
              echo "Destroying MySQL: $MYSQL_NAME"
              ssh -i ~/.ssh/deploy_key dokku@${{ secrets.DOKKU_HOST }} \
                mysql:destroy $MYSQL_NAME --force 2>/dev/null || true
            fi

            # RabbitMQ
            SHARED=$(yq e '.services.rabbitmq.environments.preview.shared // false' .dokku/services.yml 2>/dev/null)
            if [ "$SHARED" != "true" ]; then
              RABBITMQ_NAME="rabbitmq-${{ env.APP_NAME }}"
              echo "Destroying RabbitMQ: $RABBITMQ_NAME"
              ssh -i ~/.ssh/deploy_key dokku@${{ secrets.DOKKU_HOST }} \
                rabbitmq:destroy $RABBITMQ_NAME --force 2>/dev/null || true
            fi

            # Elasticsearch
            SHARED=$(yq e '.services.elasticsearch.environments.preview.shared // false' .dokku/services.yml 2>/dev/null)
            if [ "$SHARED" != "true" ]; then
              ES_NAME="elasticsearch-${{ env.APP_NAME }}"
              echo "Destroying Elasticsearch: $ES_NAME"
              ssh -i ~/.ssh/deploy_key dokku@${{ secrets.DOKKU_HOST }} \
                elasticsearch:destroy $ES_NAME --force 2>/dev/null || true
            fi
          fi

      - name: Destroy preview app
        run: |
          echo "Destroying preview app: ${{ env.APP_NAME }}"
          ssh -i ~/.ssh/deploy_key dokku@${{ secrets.DOKKU_HOST }} \
            apps:destroy ${{ env.APP_NAME }} --force || true

      - name: Update PR comment
        uses: actions/github-script@v7
        env:
          TARGET_REPO: ${{ env.TARGET_REPO }}
          PR_NUMBER: ${{ env.PR_NUMBER }}
        with:
          script: |
            const [owner, repo] = process.env.TARGET_REPO.split('/');
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            const comments = await github.rest.issues.listComments({
              owner,
              repo,
              issue_number: prNumber,
            });

            const botComment = comments.data.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('Preview Environment')
            );

            if (botComment) {
              const mergedOrClosed = context.payload.pull_request?.merged ? 'merged' : 'closed';
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: botComment.id,
                body: `## ğŸš€ Preview Environment

                | Status |
                |--------|
                | ğŸ—‘ï¸ Destroyed (PR ${mergedOrClosed}) |

                ---
                <sub>Preview environments are automatically cleaned up when PRs are closed.</sub>`
              });
            }

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Notify - Send notifications for preview events
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [setup, deploy-preview, cleanup-preview]
    if: always() && (needs.deploy-preview.result == 'success' || needs.deploy-preview.result == 'failure' || needs.cleanup-preview.result == 'success')

    env:
      APP_NAME: ${{ needs.setup.outputs.app_name }}
      PR_NUMBER: ${{ needs.setup.outputs.pr_number }}
      TARGET_REPO: ${{ needs.setup.outputs.repo }}

    steps:
      - name: Notify Slack
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          BASE_DOMAIN: ${{ secrets.BASE_DOMAIN }}
        run: |
          [ -z "$SLACK_WEBHOOK_URL" ] && exit 0

          DEPLOY_RESULT="${{ needs.deploy-preview.result }}"
          CLEANUP_RESULT="${{ needs.cleanup-preview.result }}"

          if [ "$CLEANUP_RESULT" == "success" ]; then
            COLOR="#808080"
            EMOJI="ğŸ—‘ï¸"
            TITLE="Preview Destroyed"
            STATUS="Cleaned up"
          elif [ "$DEPLOY_RESULT" == "success" ]; then
            COLOR="good"
            EMOJI="ğŸš€"
            TITLE="Preview Deployed"
            STATUS="Ready"
          else
            COLOR="danger"
            EMOJI="âŒ"
            TITLE="Preview Failed"
            STATUS="Failed"
          fi

          DOMAIN="${{ env.APP_NAME }}.${BASE_DOMAIN}"

          curl -X POST -H "Content-Type: application/json" \
            -d "{
              \"attachments\": [{
                \"color\": \"$COLOR\",
                \"blocks\": [
                  {
                    \"type\": \"section\",
                    \"text\": {
                      \"type\": \"mrkdwn\",
                      \"text\": \"$EMOJI *$TITLE*\"
                    }
                  },
                  {
                    \"type\": \"section\",
                    \"fields\": [
                      {\"type\": \"mrkdwn\", \"text\": \"*App:*\n${{ env.APP_NAME }}\"},
                      {\"type\": \"mrkdwn\", \"text\": \"*Status:*\n$STATUS\"},
                      {\"type\": \"mrkdwn\", \"text\": \"*PR:*\n<https://github.com/${{ env.TARGET_REPO }}/pull/${{ env.PR_NUMBER }}|#${{ env.PR_NUMBER }}>\"},
                      {\"type\": \"mrkdwn\", \"text\": \"*Actor:*\n${{ github.actor }}\"}
                    ]
                  }
                ],
                \"footer\": \"<https://$DOMAIN|Open Preview> | <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Workflow>\"
              }]
            }" \
            "$SLACK_WEBHOOK_URL" || true

      - name: Notify Discord
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          BASE_DOMAIN: ${{ secrets.BASE_DOMAIN }}
        run: |
          [ -z "$DISCORD_WEBHOOK_URL" ] && exit 0

          DEPLOY_RESULT="${{ needs.deploy-preview.result }}"
          CLEANUP_RESULT="${{ needs.cleanup-preview.result }}"

          if [ "$CLEANUP_RESULT" == "success" ]; then
            COLOR=8421504
            TITLE="ğŸ—‘ï¸ Preview Destroyed"
          elif [ "$DEPLOY_RESULT" == "success" ]; then
            COLOR=3066993
            TITLE="ğŸš€ Preview Deployed"
          else
            COLOR=15158332
            TITLE="âŒ Preview Failed"
          fi

          DOMAIN="${{ env.APP_NAME }}.${BASE_DOMAIN}"

          curl -H "Content-Type: application/json" \
            -d "{
              \"embeds\": [{
                \"title\": \"$TITLE\",
                \"color\": $COLOR,
                \"fields\": [
                  {\"name\": \"App\", \"value\": \"${{ env.APP_NAME }}\", \"inline\": true},
                  {\"name\": \"PR\", \"value\": \"[#${{ env.PR_NUMBER }}](https://github.com/${{ env.TARGET_REPO }}/pull/${{ env.PR_NUMBER }})\", \"inline\": true},
                  {\"name\": \"Actor\", \"value\": \"${{ github.actor }}\", \"inline\": true},
                  {\"name\": \"URL\", \"value\": \"https://$DOMAIN\", \"inline\": false}
                ],
                \"footer\": {\"text\": \"Preview Environment\"},
                \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
              }]
            }" \
            "$DISCORD_WEBHOOK_URL" || true

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Audit Log - Record preview deployment in audit log
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  audit-log-deploy:
    name: Audit Log (Deploy)
    needs: [setup, deploy-preview]
    if: always() && (needs.deploy-preview.result == 'success' || needs.deploy-preview.result == 'failure')
    uses: ./.github/workflows/audit-log.yml
    with:
      action: preview
      app_name: ${{ needs.setup.outputs.app_name }}
      environment: preview
      status: ${{ needs.deploy-preview.result }}
      commit_sha: ${{ needs.setup.outputs.head_sha }}
      metadata: '{"pr_number": "${{ needs.setup.outputs.pr_number }}", "pr_author": "${{ needs.setup.outputs.pr_author }}", "repo": "${{ needs.setup.outputs.repo }}"}'
    secrets: inherit

  audit-log-cleanup:
    name: Audit Log (Cleanup)
    needs: [setup, cleanup-preview]
    if: always() && needs.cleanup-preview.result == 'success'
    uses: ./.github/workflows/audit-log.yml
    with:
      action: cleanup
      app_name: ${{ needs.setup.outputs.app_name }}
      environment: preview
      status: success
      metadata: '{"pr_number": "${{ needs.setup.outputs.pr_number }}", "repo": "${{ needs.setup.outputs.repo }}"}'
    secrets: inherit
