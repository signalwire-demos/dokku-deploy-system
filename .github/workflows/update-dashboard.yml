# ═══════════════════════════════════════════════════════════════════════════════
# update-dashboard.yml - Update Deploy Dashboard
# ═══════════════════════════════════════════════════════════════════════════════
#
# Reusable workflow to update the deployment dashboard on GitHub Pages.
# Called after deploys, cleanups, and health checks to keep dashboard current.
#
# Dashboard location: https://signalwire-demos.github.io/dokku-deploy-system/
#
# Required Secrets:
#   - GH_ORG_TOKEN: Fine-grained PAT with Contents (read/write) and admin permissions
#   - DOKKU_HOST, DOKKU_SSH_PRIVATE_KEY, BASE_DOMAIN: For sync-from-dokku
#
# ═══════════════════════════════════════════════════════════════════════════════

name: Update Dashboard

on:
  workflow_call:
    inputs:
      app_name:
        description: 'App name'
        required: true
        type: string
      action:
        description: 'Action type (deploy, cleanup, health-check)'
        required: true
        type: string
      status:
        description: 'Status (success, failure, healthy, unhealthy)'
        required: true
        type: string
      environment:
        description: 'Environment (production, staging, development, preview)'
        required: false
        type: string
        default: ''
      url:
        description: 'App URL'
        required: false
        type: string
        default: ''
      commit_sha:
        description: 'Commit SHA'
        required: false
        type: string
        default: ''
      actor:
        description: 'Who triggered the action'
        required: false
        type: string
        default: ''
    secrets:
      GH_ORG_TOKEN:
        required: true
      BASE_DOMAIN:
        required: false

  workflow_dispatch:
    inputs:
      action:
        description: 'Action'
        type: choice
        options:
          - sync-from-dokku

jobs:
  update-dashboard:
    name: Update Dashboard
    runs-on: ubuntu-latest

    steps:
      - name: Checkout gh-pages branch
        uses: actions/checkout@v4
        with:
          repository: signalwire-demos/dokku-deploy-system
          ref: gh-pages
          fetch-depth: 0
          token: ${{ secrets.GH_ORG_TOKEN }}

      - name: Setup SSH (for sync)
        if: inputs.action == 'sync-from-dokku'
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.DOKKU_SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.DOKKU_HOST }} >> ~/.ssh/known_hosts 2>/dev/null
          cat >> ~/.ssh/config << EOF
          Host dokku
            HostName ${{ secrets.DOKKU_HOST }}
            User dokku
            IdentityFile ~/.ssh/deploy_key
            StrictHostKeyChecking no
          EOF
          chmod 600 ~/.ssh/config

      - name: Sync from Dokku
        if: inputs.action == 'sync-from-dokku'
        env:
          BASE_DOMAIN: ${{ secrets.BASE_DOMAIN }}
        run: |
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          echo "Fetching apps from Dokku..."
          APPS=$(ssh dokku apps:list | tail -n +2)

          # Start building JSON (write to root level)
          echo '{"last_updated":"'"$TIMESTAMP"'","apps":[' > apps.json

          FIRST=true
          for APP in $APPS; do
            echo "Processing: $APP"

            # Determine environment from app name
            if [[ "$APP" == *"-pr-"* ]]; then
              ENV="preview"
            elif [[ "$APP" == *"-staging" ]]; then
              ENV="staging"
            elif [[ "$APP" == *"-dev" ]]; then
              ENV="development"
            else
              ENV="production"
            fi

            # Get app URL
            URL="https://${APP}.${BASE_DOMAIN}"

            # Get container info via ps:inspect
            CONTAINER_INFO=$(ssh dokku ps:inspect "$APP" 2>/dev/null || echo "{}")
            STARTED_AT=$(echo "$CONTAINER_INFO" | jq -r '.[0].State.StartedAt // empty' 2>/dev/null || echo "")
            IS_RUNNING=$(echo "$CONTAINER_INFO" | jq -r '.[0].State.Running // false' 2>/dev/null || echo "false")
            echo "  IS_RUNNING='$IS_RUNNING' STARTED_AT='$STARTED_AT'"

            # Calculate uptime in seconds
            UPTIME_SECONDS=0
            if [ -n "$STARTED_AT" ] && [ "$STARTED_AT" != "null" ]; then
              START_EPOCH=$(date -d "$STARTED_AT" +%s 2>/dev/null || echo "0")
              NOW_EPOCH=$(date +%s)
              if [ "$START_EPOCH" -gt 0 ]; then
                UPTIME_SECONDS=$((NOW_EPOCH - START_EPOCH))
              fi
            fi
            echo "  UPTIME_SECONDS=$UPTIME_SECONDS"

            if [ "$IS_RUNNING" = "true" ]; then
              STATUS="running"
            else
              STATUS="stopped"
            fi

            # Get git revision from GIT_REV env var
            COMMIT_SHA=$(ssh dokku config:get "$APP" GIT_REV 2>/dev/null | tr -d '[:space:]' || echo "")
            echo "  COMMIT_SHA='$COMMIT_SHA'"

            # Check response time
            RESPONSE_MS=0
            UPTIME_STATUS="$STATUS"
            echo "  Checking URL: $URL"
            RESPONSE=$(curl -sk -o /dev/null -w "%{http_code} %{time_total}" --max-time 10 "$URL" 2>/dev/null || echo "000 0")
            echo "  RESPONSE='$RESPONSE'"
            HTTP_CODE=$(echo "$RESPONSE" | cut -d' ' -f1)
            TIME_TOTAL=$(echo "$RESPONSE" | cut -d' ' -f2)
            RESPONSE_MS=$(echo "$TIME_TOTAL * 1000" | bc 2>/dev/null | cut -d. -f1 || echo "0")
            [ -z "$RESPONSE_MS" ] && RESPONSE_MS=0
            echo "  HTTP_CODE=$HTTP_CODE RESPONSE_MS=$RESPONSE_MS"
            if [ "$HTTP_CODE" -ge 200 ] 2>/dev/null && [ "$HTTP_CODE" -lt 400 ] 2>/dev/null; then
              UPTIME_STATUS="healthy"
              STATUS="running"
            elif [ "$HTTP_CODE" != "000" ] 2>/dev/null; then
              UPTIME_STATUS="unhealthy"
            fi
            echo "  STATUS=$STATUS UPTIME_STATUS=$UPTIME_STATUS"

            # Add comma separator
            if [ "$FIRST" = true ]; then
              FIRST=false
            else
              echo "," >> apps.json
            fi

            # Add app entry
            cat >> apps.json << APPJSON
          {
            "name": "$APP",
            "status": "$STATUS",
            "environment": "$ENV",
            "url": "$URL",
            "last_deploy": "$TIMESTAMP",
            "last_deploy_by": "sync",
            "commit_sha": "$COMMIT_SHA",
            "uptime": {
              "status": "$UPTIME_STATUS",
              "uptime_seconds": $UPTIME_SECONDS,
              "response_time_ms": $RESPONSE_MS,
              "last_check": "$TIMESTAMP"
            }
          }
          APPJSON
          done

          echo ']}' >> apps.json

          echo ""
          echo "Dashboard synced with $(echo "$APPS" | wc -w | tr -d ' ') apps"
          cat apps.json

      - name: Update apps.json
        if: inputs.action != 'sync-from-dokku'
        env:
          BASE_DOMAIN: ${{ secrets.BASE_DOMAIN }}
        run: |
          # Initialize apps.json if it doesn't exist
          if [ ! -f apps.json ]; then
            echo '{"last_updated":"","apps":[]}' > apps.json
          fi

          APP_NAME="${{ inputs.app_name }}"
          ACTION="${{ inputs.action }}"
          STATUS="${{ inputs.status }}"
          ENVIRONMENT="${{ inputs.environment }}"
          URL="${{ inputs.url }}"
          COMMIT_SHA="${{ inputs.commit_sha }}"

          # Reconstruct URL if empty (GitHub masks outputs containing secrets)
          if [ -z "$URL" ] && [ -n "$BASE_DOMAIN" ] && [ -n "$APP_NAME" ]; then
            URL="https://${APP_NAME}.${BASE_DOMAIN}"
            echo "Reconstructed URL: $URL"
          fi
          ACTOR="${{ inputs.actor }}"
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          # Update or add app entry
          if [ "$ACTION" == "deploy" ]; then
            # Check if app exists in JSON
            APP_EXISTS=$(jq --arg name "$APP_NAME" '.apps | map(select(.name == $name)) | length' apps.json)

            if [ "$APP_EXISTS" -gt 0 ]; then
              # Update existing app
              jq --arg name "$APP_NAME" \
                 --arg status "$STATUS" \
                 --arg env "$ENVIRONMENT" \
                 --arg url "$URL" \
                 --arg sha "$COMMIT_SHA" \
                 --arg actor "$ACTOR" \
                 --arg ts "$TIMESTAMP" \
                 '(.apps[] | select(.name == $name)) |= . + {
                   status: $status,
                   environment: $env,
                   url: $url,
                   last_deploy: $ts,
                   last_deploy_by: $actor,
                   commit_sha: $sha
                 } | .last_updated = $ts' apps.json > tmp.json && mv tmp.json apps.json
            else
              # Add new app
              jq --arg name "$APP_NAME" \
                 --arg status "$STATUS" \
                 --arg env "$ENVIRONMENT" \
                 --arg url "$URL" \
                 --arg sha "$COMMIT_SHA" \
                 --arg actor "$ACTOR" \
                 --arg ts "$TIMESTAMP" \
                 '.apps += [{
                   name: $name,
                   status: $status,
                   environment: $env,
                   url: $url,
                   last_deploy: $ts,
                   last_deploy_by: $actor,
                   commit_sha: $sha,
                   uptime: {
                     status: "unknown",
                     response_time_ms: 0,
                     last_check: $ts
                   }
                 }] | .last_updated = $ts' apps.json > tmp.json && mv tmp.json apps.json
            fi

          elif [ "$ACTION" == "cleanup" ]; then
            # Remove app from dashboard
            jq --arg name "$APP_NAME" --arg ts "$TIMESTAMP" \
               '.apps = [.apps[] | select(.name != $name)] | .last_updated = $ts' \
               apps.json > tmp.json && mv tmp.json apps.json

          elif [ "$ACTION" == "health-check" ]; then
            # Update uptime info
            jq --arg name "$APP_NAME" \
               --arg status "$STATUS" \
               --arg ts "$TIMESTAMP" \
               '(.apps[] | select(.name == $name)).uptime |= . + {
                 status: $status,
                 last_check: $ts
               } | .last_updated = $ts' apps.json > tmp.json && mv tmp.json apps.json
          fi

          echo "Updated dashboard for $APP_NAME ($ACTION: $STATUS)"
          cat apps.json

      - name: Commit and push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add apps.json

          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update dashboard: ${{ inputs.app_name || 'sync' }} ${{ inputs.action }}"

            # Retry push with pull/rebase to handle concurrent updates
            MAX_RETRIES=3
            RETRY=0
            while [ $RETRY -lt $MAX_RETRIES ]; do
              if git push; then
                echo "Push successful"
                break
              else
                RETRY=$((RETRY + 1))
                if [ $RETRY -lt $MAX_RETRIES ]; then
                  echo "Push failed, retrying ($RETRY/$MAX_RETRIES)..."
                  git pull --rebase
                else
                  echo "::warning::Failed to push dashboard update after $MAX_RETRIES retries"
                fi
              fi
            done
          fi
