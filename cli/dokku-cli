#!/bin/bash
# ═══════════════════════════════════════════════════════════════════════════════
# dokku-cli - Developer CLI for Dokku deployments
# ═══════════════════════════════════════════════════════════════════════════════
#
# A developer-friendly CLI wrapper for common Dokku operations.
# Simplifies app management, logging, deployment, and debugging.
#
# Installation:
#   chmod +x dokku-cli
#   sudo mv dokku-cli /usr/local/bin/
#
# Configuration:
#   Set DOKKU_HOST and SSH_KEY in your shell profile, or use a config file.
#
# ═══════════════════════════════════════════════════════════════════════════════

set -e

# ─────────────────────────────────────────────────────────────────────────────
# Configuration
# ─────────────────────────────────────────────────────────────────────────────

# Load config from file if exists
CONFIG_FILE="${HOME}/.dokku-cli"
if [ -f "$CONFIG_FILE" ]; then
    source "$CONFIG_FILE"
fi

# Configuration (can be overridden by environment or config file)
DOKKU_HOST="${DOKKU_HOST:-dokku.yourdomain.com}"
SSH_KEY="${SSH_KEY:-${HOME}/.ssh/dokku_deploy}"
BASE_DOMAIN="${BASE_DOMAIN:-yourdomain.com}"

# Output format (set via --json or --quiet flags)
OUTPUT_FORMAT="${OUTPUT_FORMAT:-text}"
QUIET_MODE="${QUIET_MODE:-false}"

# ─────────────────────────────────────────────────────────────────────────────
# Colors and formatting
# ─────────────────────────────────────────────────────────────────────────────

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

log_info()    { echo -e "${BLUE}ℹ${NC} $1"; }
log_success() { echo -e "${GREEN}✓${NC} $1"; }
log_warning() { echo -e "${YELLOW}⚠${NC} $1"; }
log_error()   { echo -e "${RED}✗${NC} $1"; }
log_header()  { echo -e "\n${BOLD}${CYAN}$1${NC}\n"; }

# ─────────────────────────────────────────────────────────────────────────────
# SSH helper
# ─────────────────────────────────────────────────────────────────────────────

dokku_ssh() {
    if [ -f "$SSH_KEY" ]; then
        ssh -i "$SSH_KEY" "dokku@$DOKKU_HOST" "$@"
    else
        ssh "dokku@$DOKKU_HOST" "$@"
    fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Interactive mode helpers
# ─────────────────────────────────────────────────────────────────────────────

check_fzf() {
    if ! command -v fzf &>/dev/null; then
        log_error "Interactive mode requires 'fzf' (fuzzy finder)"
        echo ""
        echo "Install fzf:"
        echo "  macOS:   brew install fzf"
        echo "  Ubuntu:  sudo apt install fzf"
        echo "  Fedora:  sudo dnf install fzf"
        echo "  Arch:    sudo pacman -S fzf"
        echo ""
        echo "Or visit: https://github.com/junegunn/fzf#installation"
        exit 1
    fi
}

# Get app info for fzf preview
get_app_preview() {
    local app="$1"

    echo -e "${BOLD}═══ $app ═══${NC}"
    echo ""

    # Status
    local status=$(dokku_ssh ps:report "$app" 2>/dev/null | grep -E "running|stopped" | head -1 || echo "unknown")
    echo -e "${BOLD}Status:${NC} $status"

    # URL
    echo -e "${BOLD}URL:${NC} https://$app.$BASE_DOMAIN"

    # Last deploy (from GIT_REV)
    local git_rev=$(dokku_ssh config:get "$app" GIT_REV 2>/dev/null | head -c 7)
    [ -n "$git_rev" ] && echo -e "${BOLD}Commit:${NC} $git_rev"

    # Resources
    local resources=$(dokku_ssh resource:report "$app" 2>/dev/null | grep -E "memory|cpu" | head -2)
    if [ -n "$resources" ]; then
        echo ""
        echo -e "${BOLD}Resources:${NC}"
        echo "$resources" | sed 's/^/  /'
    fi

    # Lock status
    local locked=$(dokku_ssh config:get "$app" DEPLOY_LOCKED 2>/dev/null)
    if [ "$locked" == "true" ]; then
        local reason=$(dokku_ssh config:get "$app" DEPLOY_LOCK_REASON 2>/dev/null)
        echo ""
        echo -e "${RED}LOCKED:${NC} $reason"
    fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Resolve app alias
# ─────────────────────────────────────────────────────────────────────────────

resolve_alias() {
    local name="$1"
    local alias_var="ALIAS_$(echo "$name" | tr '[:lower:]' '[:upper:]')"

    # Check if alias exists in config
    if [ -f "$CONFIG_FILE" ]; then
        local resolved=$(grep "^$alias_var=" "$CONFIG_FILE" 2>/dev/null | cut -d'=' -f2 | tr -d '"')
        if [ -n "$resolved" ]; then
            echo "$resolved"
            return
        fi
    fi
    echo "$name"
}

# ─────────────────────────────────────────────────────────────────────────────
# Get app name (from argument or current git repo)
# ─────────────────────────────────────────────────────────────────────────────

get_app_name() {
    local name=""
    if [ -n "$1" ]; then
        name="$1"
    elif git rev-parse --is-inside-work-tree &>/dev/null; then
        name=$(basename "$(git rev-parse --show-toplevel)")
    else
        log_error "No app name provided and not in a git repository"
        exit 1
    fi

    # Resolve alias
    resolve_alias "$name"
}

# ─────────────────────────────────────────────────────────────────────────────
# Commands
# ─────────────────────────────────────────────────────────────────────────────

cmd_list() {
    if [ "$OUTPUT_FORMAT" == "json" ]; then
        # JSON output
        local apps=$(dokku_ssh apps:list 2>/dev/null | tail -n +2)
        echo '{"apps":['
        local first=true
        for app in $apps; do
            [ "$first" = true ] && first=false || echo ","
            echo -n "\"$app\""
        done
        echo ']}'
    elif [ "$QUIET_MODE" == "true" ]; then
        # Quiet mode - just app names
        dokku_ssh apps:list 2>/dev/null | tail -n +2
    else
        log_header "All Apps"
        dokku_ssh apps:list
    fi
}

cmd_info() {
    local APP=$(get_app_name "$1")
    log_header "App Info: $APP"

    echo -e "${BOLD}Status${NC}"
    dokku_ssh ps:report "$APP" 2>/dev/null || echo "  Not running"

    echo ""
    echo -e "${BOLD}Domains${NC}"
    dokku_ssh domains:report "$APP" 2>/dev/null || echo "  No domains"

    echo ""
    echo -e "${BOLD}SSL${NC}"
    dokku_ssh letsencrypt:list 2>/dev/null | grep -E "^$APP " || echo "  No SSL certificate"

    echo ""
    echo -e "${BOLD}Resources${NC}"
    dokku_ssh resource:report "$APP" 2>/dev/null || echo "  Default resources"
}

cmd_logs() {
    local APP=$(get_app_name "$1")
    local NUM="${2:---num 100}"
    log_info "Logs for $APP"
    dokku_ssh logs "$APP" $NUM
}

cmd_logs_follow() {
    local APP=$(get_app_name "$1")
    log_info "Following logs for $APP (Ctrl+C to stop)"
    dokku_ssh logs "$APP" -t
}

cmd_config() {
    local APP=$(get_app_name "$1")
    log_header "Environment Variables: $APP"
    dokku_ssh config:show "$APP"
}

cmd_config_set() {
    local APP=$(get_app_name "$1")
    shift
    if [ $# -eq 0 ]; then
        log_error "Usage: dokku-cli config:set [app] KEY=value [KEY2=value2 ...]"
        exit 1
    fi
    log_info "Setting config for $APP..."
    dokku_ssh config:set "$APP" "$@"
    log_success "Config updated"
}

cmd_config_unset() {
    local APP=$(get_app_name "$1")
    shift
    if [ $# -eq 0 ]; then
        log_error "Usage: dokku-cli config:unset [app] KEY [KEY2 ...]"
        exit 1
    fi
    log_info "Unsetting config for $APP..."
    dokku_ssh config:unset "$APP" "$@"
    log_success "Config updated"
}

cmd_shell() {
    local APP=$(get_app_name "$1")
    log_info "Opening shell for $APP..."
    dokku_ssh enter "$APP" web
}

cmd_run() {
    local APP=$(get_app_name "$1")
    shift
    if [ $# -eq 0 ]; then
        log_error "Usage: dokku-cli run [app] <command>"
        exit 1
    fi
    log_info "Running command in $APP..."
    dokku_ssh run "$APP" "$@"
}

cmd_restart() {
    local APP=$(get_app_name "$1")
    log_info "Restarting $APP..."
    dokku_ssh ps:restart "$APP"
    log_success "Restarted"
}

cmd_stop() {
    local APP=$(get_app_name "$1")
    log_warning "Stopping $APP..."
    dokku_ssh ps:stop "$APP"
    log_success "Stopped"
}

cmd_start() {
    local APP=$(get_app_name "$1")
    log_info "Starting $APP..."
    dokku_ssh ps:start "$APP"
    log_success "Started"
}

cmd_scale() {
    local APP=$(get_app_name "$1")
    shift
    if [ $# -eq 0 ]; then
        log_header "Current Scale: $APP"
        dokku_ssh ps:scale "$APP"
    else
        log_info "Scaling $APP..."
        dokku_ssh ps:scale "$APP" "$@"
        log_success "Scaled"
    fi
}

cmd_deploy() {
    local APP=$(get_app_name "$1")
    local BRANCH="${2:-HEAD}"

    log_header "Deploying $APP"

    # Check if we're in a git repo
    if ! git rev-parse --is-inside-work-tree &>/dev/null; then
        log_error "Not in a git repository"
        exit 1
    fi

    # Check for uncommitted changes
    if ! git diff-index --quiet HEAD -- 2>/dev/null; then
        log_warning "You have uncommitted changes"
        read -p "Continue anyway? (y/N): " confirm
        if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
            exit 1
        fi
    fi

    # Setup remote
    log_info "Configuring git remote..."
    git remote add dokku "dokku@$DOKKU_HOST:$APP" 2>/dev/null || \
    git remote set-url dokku "dokku@$DOKKU_HOST:$APP"

    # Deploy
    log_info "Pushing to Dokku..."
    if [ -f "$SSH_KEY" ]; then
        GIT_SSH_COMMAND="ssh -i $SSH_KEY" git push dokku "$BRANCH:main" --force
    else
        git push dokku "$BRANCH:main" --force
    fi

    log_success "Deployed!"
    echo ""
    log_info "URL: https://$APP.$BASE_DOMAIN"
}

cmd_rollback() {
    local APP=$(get_app_name "$1")
    local VERSION="$2"

    if [ -n "$VERSION" ]; then
        log_warning "Rolling back $APP to $VERSION..."
        dokku_ssh releases:rollback "$APP" "$VERSION"
    else
        log_warning "Rolling back $APP to previous version..."
        dokku_ssh releases:rollback "$APP"
    fi
    log_success "Rolled back"
}

cmd_releases() {
    local APP=$(get_app_name "$1")
    log_header "Releases: $APP"
    dokku_ssh releases:list "$APP"
}

cmd_create() {
    local APP="$1"
    if [ -z "$APP" ]; then
        log_error "Usage: dokku-cli create <app-name>"
        exit 1
    fi
    log_info "Creating app: $APP"
    dokku_ssh apps:create "$APP"
    log_success "Created"
    log_info "Domain: $APP.$BASE_DOMAIN"
}

cmd_destroy() {
    local APP=$(get_app_name "$1")

    log_warning "This will PERMANENTLY delete $APP and all its data!"
    echo ""
    read -p "Type the app name to confirm: " CONFIRM

    if [ "$CONFIRM" == "$APP" ]; then
        dokku_ssh apps:destroy "$APP" --force
        log_success "Destroyed $APP"
    else
        log_error "Confirmation failed. Aborting."
        exit 1
    fi
}

cmd_ssl() {
    local APP=$(get_app_name "$1")
    local ACTION="${2:-status}"

    case "$ACTION" in
        enable)
            log_info "Enabling SSL for $APP..."
            dokku_ssh letsencrypt:enable "$APP"
            log_success "SSL enabled"
            ;;
        disable)
            log_info "Disabling SSL for $APP..."
            dokku_ssh letsencrypt:disable "$APP"
            log_success "SSL disabled"
            ;;
        status|*)
            log_header "SSL Status: $APP"
            dokku_ssh letsencrypt:list 2>/dev/null | grep -E "^$APP |App " || echo "No SSL certificate"
            ;;
    esac
}

cmd_domains() {
    local APP=$(get_app_name "$1")
    local ACTION="$2"
    shift 2 2>/dev/null || true

    case "$ACTION" in
        add)
            if [ -z "$1" ]; then
                log_error "Usage: dokku-cli domains add [app] <domain>"
                exit 1
            fi
            log_info "Adding domain $1 to $APP..."
            dokku_ssh domains:add "$APP" "$1"
            log_success "Domain added"
            ;;
        remove)
            if [ -z "$1" ]; then
                log_error "Usage: dokku-cli domains remove [app] <domain>"
                exit 1
            fi
            log_info "Removing domain $1 from $APP..."
            dokku_ssh domains:remove "$APP" "$1"
            log_success "Domain removed"
            ;;
        *)
            log_header "Domains: $APP"
            dokku_ssh domains:report "$APP"
            ;;
    esac
}

cmd_db() {
    local APP=$(get_app_name "$1")
    local ACTION="${2:-info}"
    local SERVICE="${3:-postgres}"

    DB_NAME="$SERVICE-$APP"

    case "$ACTION" in
        create)
            log_info "Creating $SERVICE database: $DB_NAME"
            dokku_ssh "$SERVICE:create" "$DB_NAME"
            dokku_ssh "$SERVICE:link" "$DB_NAME" "$APP"
            log_success "Database created and linked"
            ;;
        connect)
            log_info "Connecting to $DB_NAME..."
            dokku_ssh "$SERVICE:connect" "$DB_NAME"
            ;;
        backup)
            local BACKUP_FILE="${APP}-$(date +%Y%m%d_%H%M%S).dump"
            log_info "Backing up $SERVICE database: $DB_NAME"
            log_info "Saving to: $BACKUP_FILE"
            dokku_ssh "$SERVICE:export" "$DB_NAME" > "$BACKUP_FILE"
            log_success "Backup saved: $BACKUP_FILE ($(ls -lh "$BACKUP_FILE" | awk '{print $5}'))"
            ;;
        backup-server)
            # Backup directly to server storage
            TIMESTAMP=$(date +%Y%m%d_%H%M%S)
            BACKUP_DIR="/var/backups/dokku/$SERVICE/$APP"
            BACKUP_FILE="$BACKUP_DIR/${TIMESTAMP}.gz"

            log_info "Backing up $SERVICE database: $DB_NAME"
            log_info "Saving to server: $BACKUP_FILE"

            # Create directory and backup
            ssh -i "$SSH_KEY" "dokku@$DOKKU_HOST" "mkdir -p $BACKUP_DIR"
            dokku_ssh "$SERVICE:export" "$DB_NAME" 2>/dev/null | gzip | \
              ssh -i "$SSH_KEY" "dokku@$DOKKU_HOST" "cat > $BACKUP_FILE"

            if [ $? -eq 0 ]; then
                SIZE=$(ssh -i "$SSH_KEY" "dokku@$DOKKU_HOST" "ls -lh $BACKUP_FILE | awk '{print \$5}'" 2>/dev/null)
                log_success "Backup saved: $BACKUP_FILE ($SIZE)"
            else
                log_error "Backup failed"
            fi
            ;;
        restore)
            local BACKUP_PATH="$SERVICE"  # Third arg is actually the file path
            if [ -z "$BACKUP_PATH" ] || [ "$BACKUP_PATH" == "postgres" ] || [ "$BACKUP_PATH" == "mysql" ]; then
                log_error "Usage: dokku-cli db restore <app> <backup-file>"
                exit 1
            fi

            if [ ! -f "$BACKUP_PATH" ]; then
                log_error "Backup file not found: $BACKUP_PATH"
                exit 1
            fi

            SERVICE="${4:-postgres}"
            DB_NAME="$SERVICE-$APP"

            log_warning "This will replace all data in $DB_NAME with the backup!"
            read -p "Are you sure? (yes/no): " CONFIRM
            if [ "$CONFIRM" != "yes" ]; then
                log_info "Restore cancelled"
                exit 0
            fi

            log_info "Restoring $DB_NAME from $BACKUP_PATH..."
            if [[ "$BACKUP_PATH" == *.gz ]]; then
                gunzip -c "$BACKUP_PATH" | dokku_ssh "$SERVICE:import" "$DB_NAME"
            else
                dokku_ssh "$SERVICE:import" "$DB_NAME" < "$BACKUP_PATH"
            fi
            log_success "Restore complete"
            ;;
        list-backups)
            log_header "Backups for $APP"
            echo ""
            echo "Local backups:"
            ls -lh ${APP}-*.dump 2>/dev/null || echo "  No local backups found"
            echo ""
            echo "Server backups (/var/backups/dokku/):"
            ssh -i "$SSH_KEY" "dokku@$DOKKU_HOST" "
              for service in postgres mysql redis mongo rabbitmq elasticsearch; do
                DIR=\"/var/backups/dokku/\$service/$APP\"
                if [ -d \"\$DIR\" ]; then
                  echo \"  \$service:\"
                  ls -lh \"\$DIR\"/*.gz 2>/dev/null | awk '{print \"    \" \$9 \" (\" \$5 \")\"}' || echo \"    No backups\"
                fi
              done
            " 2>/dev/null || echo "  Unable to list server backups"
            ;;
        info|*)
            log_header "Database: $DB_NAME"
            dokku_ssh "$SERVICE:info" "$DB_NAME" 2>/dev/null || echo "Database not found"
            ;;
    esac
}

cmd_lock() {
    local APP=$(get_app_name "$1")
    local REASON="${2:-Manual lock via CLI}"

    # Check if already locked
    LOCKED=$(dokku_ssh config:get "$APP" DEPLOY_LOCKED 2>/dev/null || echo "false")
    if [ "$LOCKED" == "true" ]; then
        EXISTING_REASON=$(dokku_ssh config:get "$APP" DEPLOY_LOCK_REASON 2>/dev/null)
        log_warning "$APP is already locked"
        echo "  Reason: $EXISTING_REASON"
        return 0
    fi

    TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    LOCKED_BY="${USER:-$(whoami)}"

    log_warning "Locking $APP..."
    dokku_ssh config:set --no-restart "$APP" \
        DEPLOY_LOCKED=true \
        "DEPLOY_LOCK_REASON=$REASON" \
        "DEPLOY_LOCK_BY=$LOCKED_BY" \
        "DEPLOY_LOCK_AT=$TIMESTAMP"

    log_success "Locked! Deployments are now blocked."
    echo "  Reason: $REASON"
}

cmd_unlock() {
    local APP=$(get_app_name "$1")

    # Check if locked
    LOCKED=$(dokku_ssh config:get "$APP" DEPLOY_LOCKED 2>/dev/null || echo "false")
    if [ "$LOCKED" != "true" ]; then
        log_info "$APP is not locked"
        return 0
    fi

    PREV_REASON=$(dokku_ssh config:get "$APP" DEPLOY_LOCK_REASON 2>/dev/null)
    PREV_BY=$(dokku_ssh config:get "$APP" DEPLOY_LOCK_BY 2>/dev/null)

    log_info "Unlocking $APP..."
    dokku_ssh config:unset --no-restart "$APP" \
        DEPLOY_LOCKED \
        DEPLOY_LOCK_REASON \
        DEPLOY_LOCK_BY \
        DEPLOY_LOCK_AT

    log_success "Unlocked! Deployments are now allowed."
    echo "  Previously locked by: $PREV_BY"
    echo "  Reason was: $PREV_REASON"
}

cmd_lock_status() {
    local APP=$(get_app_name "$1")

    LOCKED=$(dokku_ssh config:get "$APP" DEPLOY_LOCKED 2>/dev/null || echo "false")

    log_header "Lock Status: $APP"

    if [ "$LOCKED" == "true" ]; then
        REASON=$(dokku_ssh config:get "$APP" DEPLOY_LOCK_REASON 2>/dev/null)
        LOCKED_BY=$(dokku_ssh config:get "$APP" DEPLOY_LOCK_BY 2>/dev/null)
        LOCKED_AT=$(dokku_ssh config:get "$APP" DEPLOY_LOCK_AT 2>/dev/null)

        echo -e "${RED}LOCKED${NC} - Deployments are blocked"
        echo ""
        echo "  Reason:    $REASON"
        echo "  Locked by: $LOCKED_BY"
        echo "  Locked at: $LOCKED_AT"
    else
        echo -e "${GREEN}UNLOCKED${NC} - Deployments are allowed"
    fi
}

cmd_setup() {
    log_header "Dokku CLI Setup"

    echo "This will create a configuration file at ~/.dokku-cli"
    echo ""

    read -p "Dokku host [$DOKKU_HOST]: " input_host
    DOKKU_HOST="${input_host:-$DOKKU_HOST}"

    read -p "SSH key path [$SSH_KEY]: " input_key
    SSH_KEY="${input_key:-$SSH_KEY}"

    read -p "Base domain [$BASE_DOMAIN]: " input_domain
    BASE_DOMAIN="${input_domain:-$BASE_DOMAIN}"

    cat > "$CONFIG_FILE" << EOF
# Dokku CLI Configuration
DOKKU_HOST="$DOKKU_HOST"
SSH_KEY="$SSH_KEY"
BASE_DOMAIN="$BASE_DOMAIN"

# App Aliases (format: ALIAS_NAME="actual-app-name")
# Example:
# ALIAS_PROD="myapp"
# ALIAS_STG="myapp-staging"
EOF

    log_success "Configuration saved to $CONFIG_FILE"

    echo ""
    log_info "Testing connection..."
    if dokku_ssh version 2>/dev/null; then
        log_success "Connected to Dokku!"
    else
        log_error "Could not connect to Dokku"
        log_info "Check your DOKKU_HOST and SSH_KEY settings"
    fi
}

cmd_alias() {
    local ACTION="${1:-list}"
    local ALIAS_NAME="$2"
    local APP_NAME="$3"

    case "$ACTION" in
        list)
            log_header "App Aliases"
            if [ -f "$CONFIG_FILE" ]; then
                local aliases=$(grep "^ALIAS_" "$CONFIG_FILE" 2>/dev/null)
                if [ -n "$aliases" ]; then
                    echo "$aliases" | while read line; do
                        local name=$(echo "$line" | cut -d'=' -f1 | sed 's/ALIAS_//' | tr '[:upper:]' '[:lower:]')
                        local app=$(echo "$line" | cut -d'=' -f2 | tr -d '"')
                        echo "  $name -> $app"
                    done
                else
                    echo "  No aliases configured"
                    echo ""
                    echo "  Add with: dokku-cli alias add <name> <app>"
                fi
            else
                log_error "Config file not found. Run 'dokku-cli setup' first."
            fi
            ;;
        add|set)
            if [ -z "$ALIAS_NAME" ] || [ -z "$APP_NAME" ]; then
                log_error "Usage: dokku-cli alias add <name> <app>"
                exit 1
            fi
            local alias_var="ALIAS_$(echo "$ALIAS_NAME" | tr '[:lower:]' '[:upper:]')"

            # Remove existing alias if present
            if [ -f "$CONFIG_FILE" ]; then
                sed -i.bak "/^$alias_var=/d" "$CONFIG_FILE"
                rm -f "${CONFIG_FILE}.bak"
            fi

            # Add new alias
            echo "$alias_var=\"$APP_NAME\"" >> "$CONFIG_FILE"
            log_success "Alias '$ALIAS_NAME' -> '$APP_NAME' added"
            log_info "Now you can use: dokku-cli logs $ALIAS_NAME"
            ;;
        remove|rm|delete)
            if [ -z "$ALIAS_NAME" ]; then
                log_error "Usage: dokku-cli alias remove <name>"
                exit 1
            fi
            local alias_var="ALIAS_$(echo "$ALIAS_NAME" | tr '[:lower:]' '[:upper:]')"

            if [ -f "$CONFIG_FILE" ]; then
                if grep -q "^$alias_var=" "$CONFIG_FILE"; then
                    sed -i.bak "/^$alias_var=/d" "$CONFIG_FILE"
                    rm -f "${CONFIG_FILE}.bak"
                    log_success "Alias '$ALIAS_NAME' removed"
                else
                    log_error "Alias '$ALIAS_NAME' not found"
                fi
            fi
            ;;
        *)
            log_error "Unknown alias action: $ACTION"
            echo "Usage: dokku-cli alias [list|add|remove] [name] [app]"
            exit 1
            ;;
    esac
}

# ─────────────────────────────────────────────────────────────────────────────
# Interactive Mode Commands
# ─────────────────────────────────────────────────────────────────────────────

# Pick an app interactively
cmd_pick() {
    check_fzf

    local apps=$(dokku_ssh apps:list 2>/dev/null | tail -n +2)

    if [ -z "$apps" ]; then
        log_error "No apps found"
        exit 1
    fi

    # Create a temp script for preview (fzf runs in subshell)
    local preview_script=$(mktemp)
    cat > "$preview_script" << 'PREVIEW_EOF'
#!/bin/bash
APP="$1"
CONFIG_FILE="${HOME}/.dokku-cli"
[ -f "$CONFIG_FILE" ] && source "$CONFIG_FILE"
DOKKU_HOST="${DOKKU_HOST:-dokku.yourdomain.com}"
SSH_KEY="${SSH_KEY:-${HOME}/.ssh/dokku_deploy}"
BASE_DOMAIN="${BASE_DOMAIN:-yourdomain.com}"

dokku_ssh() {
    if [ -f "$SSH_KEY" ]; then
        ssh -i "$SSH_KEY" "dokku@$DOKKU_HOST" "$@" 2>/dev/null
    else
        ssh "dokku@$DOKKU_HOST" "$@" 2>/dev/null
    fi
}

echo "═══ $APP ═══"
echo ""
echo "URL: https://$APP.$BASE_DOMAIN"
echo ""

# Quick status check
STATUS=$(dokku_ssh ps:report "$APP" 2>/dev/null | grep -i "status" | head -1)
[ -n "$STATUS" ] && echo "$STATUS"

# Process count
PROCS=$(dokku_ssh ps:report "$APP" 2>/dev/null | grep -i "running" | head -1)
[ -n "$PROCS" ] && echo "$PROCS"

# Lock status
LOCKED=$(dokku_ssh config:get "$APP" DEPLOY_LOCKED 2>/dev/null)
if [ "$LOCKED" == "true" ]; then
    REASON=$(dokku_ssh config:get "$APP" DEPLOY_LOCK_REASON 2>/dev/null)
    echo ""
    echo "⚠️  LOCKED: $REASON"
fi
PREVIEW_EOF
    chmod +x "$preview_script"

    local selected=$(echo "$apps" | fzf \
        --header="Select an app (ESC to cancel)" \
        --preview="$preview_script {}" \
        --preview-window=right:50%:wrap \
        --height=80% \
        --border \
        --prompt="App > ")

    rm -f "$preview_script"

    [ -n "$selected" ] && echo "$selected"
}

# Select action for an app
select_action() {
    local app="$1"

    local actions="View Logs
Follow Logs (live)
Restart
View Config
Set Config Variable
Scale Processes
Open Shell
─────────────────
Deploy (from branch)
Rollback
View Releases
─────────────────
Lock Deployments
Unlock Deployments
Check Lock Status
─────────────────
Database Operations
SSL Management
Domain Management
─────────────────
⚠️  Destroy App"

    echo "$actions" | fzf \
        --header="$app - Select action" \
        --height=80% \
        --border \
        --prompt="Action > "
}

# Select git branch
select_branch() {
    check_fzf

    if ! git rev-parse --is-inside-work-tree &>/dev/null; then
        log_error "Not in a git repository"
        return 1
    fi

    local branches=$(git branch -a 2>/dev/null | \
        sed 's/^[* ]*//' | \
        sed 's/remotes\/origin\///' | \
        grep -v "HEAD" | \
        sort -u)

    echo "$branches" | fzf \
        --header="Select branch to deploy" \
        --preview="git log --oneline -10 {} 2>/dev/null || echo 'No commits'" \
        --preview-window=right:50%:wrap \
        --height=80% \
        --border \
        --prompt="Branch > "
}

# Database operations submenu
interactive_db() {
    local app="$1"

    local actions="Connect to Database
View Database Info
Backup to Local File
Backup to Server
Restore from Backup
List All Backups"

    local action=$(echo "$actions" | fzf \
        --header="$app - Database Operations" \
        --height=50% \
        --border \
        --prompt="DB Action > ")

    case "$action" in
        "Connect to Database")     cmd_db "$app" connect ;;
        "View Database Info")      cmd_db "$app" info ;;
        "Backup to Local File")    cmd_db "$app" backup ;;
        "Backup to Server")        cmd_db "$app" backup-server ;;
        "Restore from Backup")
            log_info "Enter backup file path:"
            read -p "> " backup_file
            [ -n "$backup_file" ] && cmd_db "$app" restore "$backup_file"
            ;;
        "List All Backups")        cmd_db "$app" list-backups ;;
    esac
}

# Main interactive mode
cmd_interactive() {
    check_fzf

    log_info "Loading apps..."

    while true; do
        # Pick an app
        local app=$(cmd_pick)
        [ -z "$app" ] && break

        # Pick an action
        local action=$(select_action "$app")
        [ -z "$action" ] && continue

        # Execute action
        case "$action" in
            "View Logs")
                cmd_logs "$app"
                echo ""
                read -p "Press Enter to continue..."
                ;;
            "Follow Logs (live)")
                log_info "Press Ctrl+C to stop following logs"
                cmd_logs_follow "$app"
                ;;
            "Restart")
                cmd_restart "$app"
                sleep 1
                ;;
            "View Config")
                cmd_config "$app"
                echo ""
                read -p "Press Enter to continue..."
                ;;
            "Set Config Variable")
                echo "Enter KEY=value (or multiple: KEY1=val1 KEY2=val2):"
                read -p "> " config_input
                if [ -n "$config_input" ]; then
                    cmd_config_set "$app" $config_input
                fi
                sleep 1
                ;;
            "Scale Processes")
                echo "Current scale:"
                dokku_ssh ps:scale "$app"
                echo ""
                echo "Enter new scale (e.g., web=2 worker=1):"
                read -p "> " scale_input
                if [ -n "$scale_input" ]; then
                    cmd_scale "$app" $scale_input
                fi
                sleep 1
                ;;
            "Open Shell")
                cmd_shell "$app"
                ;;
            "Deploy (from branch)")
                local branch=$(select_branch)
                if [ -n "$branch" ]; then
                    cmd_deploy "$app" "$branch"
                    read -p "Press Enter to continue..."
                fi
                ;;
            "Rollback")
                echo "Recent releases:"
                cmd_releases "$app"
                echo ""
                echo "Enter version to rollback to (or press Enter for previous):"
                read -p "> " version
                cmd_rollback "$app" "$version"
                sleep 2
                ;;
            "View Releases")
                cmd_releases "$app"
                echo ""
                read -p "Press Enter to continue..."
                ;;
            "Lock Deployments")
                echo "Enter lock reason:"
                read -p "> " reason
                cmd_lock "$app" "${reason:-Manual lock}"
                sleep 1
                ;;
            "Unlock Deployments")
                cmd_unlock "$app"
                sleep 1
                ;;
            "Check Lock Status")
                cmd_lock_status "$app"
                echo ""
                read -p "Press Enter to continue..."
                ;;
            "Database Operations")
                interactive_db "$app"
                read -p "Press Enter to continue..."
                ;;
            "SSL Management")
                cmd_ssl "$app"
                echo ""
                echo "Actions: enable, disable"
                read -p "Action (or Enter to skip): " ssl_action
                [ -n "$ssl_action" ] && cmd_ssl "$app" "$ssl_action"
                sleep 1
                ;;
            "Domain Management")
                cmd_domains "$app"
                echo ""
                echo "Actions: add <domain>, remove <domain>"
                read -p "Action (or Enter to skip): " domain_action
                if [ -n "$domain_action" ]; then
                    cmd_domains "$app" $domain_action
                fi
                sleep 1
                ;;
            "⚠️  Destroy App")
                cmd_destroy "$app"
                break  # Exit loop if app destroyed
                ;;
            ─*)
                # Separator line, ignore
                continue
                ;;
        esac
    done

    log_info "Exiting interactive mode"
}

cmd_help() {
    cat << 'EOF'
╔═══════════════════════════════════════════════════════════════════════════════╗
║                              DOKKU CLI                                         ║
║                   Developer tools for Dokku deployments                        ║
╚═══════════════════════════════════════════════════════════════════════════════╝

Usage: dokku-cli [--json|--quiet] <command> [app] [options]

If [app] is not provided, it will be inferred from the current git repository.
You can also use aliases instead of app names (see ALIASES section).

GLOBAL OPTIONS
  --json                     Output in JSON format (where supported)
  --quiet, -q                Minimal output (just data, no headers)

GENERAL
  setup                      Configure CLI settings
  list                       List all apps
  create <name>              Create a new app
  destroy [app]              Permanently delete an app

APP INFO
  info [app]                 Show app information
  logs [app] [--num N]       View app logs (default: 100 lines)
  logs:follow [app]          Follow app logs in real-time

CONFIGURATION
  config [app]               Show environment variables
  config:set [app] K=V...    Set environment variables
  config:unset [app] K...    Remove environment variables

PROCESS MANAGEMENT
  restart [app]              Restart app
  start [app]                Start app
  stop [app]                 Stop app
  scale [app] [web=N...]     View or set process scaling
  shell [app]                Open interactive shell in app

DEPLOYMENT
  deploy [app] [branch]      Deploy app via git push
  rollback [app] [version]   Rollback to previous release
  releases [app]             List releases

DEPLOY LOCKS
  lock [app] [reason]        Lock app (block deployments)
  unlock [app]               Unlock app (allow deployments)
  lock:status [app]          Check lock status

SSL & DOMAINS
  ssl [app] [enable|disable] Manage SSL certificates
  domains [app]              List domains
  domains add [app] <domain> Add a domain
  domains remove [app] <d>   Remove a domain

DATABASE
  db [app] info [service]         Show database info
  db [app] create [service]       Create and link database
  db [app] connect [service]      Connect to database shell
  db [app] backup [service]       Export database to local file
  db [app] backup-server [svc]    Backup to server storage
  db [app] restore <file> [svc]   Restore from backup file
  db [app] list-backups           List available backups

RUN COMMANDS
  run [app] <command>        Run one-off command

ALIASES
  alias                      List all aliases
  alias add <name> <app>     Create alias (e.g., prod -> myapp)
  alias remove <name>        Remove alias

INTERACTIVE MODE (requires fzf)
  i, interactive             Full interactive TUI with app browser
  pick                       Pick an app interactively (for piping)
  <command> -i               Interactive app selection for any command

EXAMPLES
  dokku-cli logs myapp --num 50
  dokku-cli config:set myapp DEBUG=true SECRET_KEY=abc123
  dokku-cli run myapp python manage.py migrate
  dokku-cli deploy myapp main
  dokku-cli db myapp create postgres
  dokku-cli --json list
  dokku-cli alias add prod myapp
  dokku-cli logs prod            # Uses alias
  dokku-cli i                    # Interactive mode
  dokku-cli logs -i              # Pick app, then show logs
  dokku-cli restart $(dokku-cli pick)  # Pipe app selection

CONFIGURATION
  Settings are stored in ~/.dokku-cli
  Run 'dokku-cli setup' to configure.

SHELL COMPLETIONS
  Bash: source /path/to/completions/dokku-cli.bash
  Zsh:  Add completions dir to fpath, then compinit
  Fish: cp dokku-cli.fish ~/.config/fish/completions/

EOF
}

# ─────────────────────────────────────────────────────────────────────────────
# Main
# ─────────────────────────────────────────────────────────────────────────────

# Parse global options
while [[ "$1" == -* ]]; do
    case "$1" in
        --json)
            OUTPUT_FORMAT="json"
            shift
            ;;
        --quiet|-q)
            QUIET_MODE="true"
            shift
            ;;
        --help|-h)
            cmd_help
            exit 0
            ;;
        --version|-v)
            echo "dokku-cli v2.1.0"
            exit 0
            ;;
        *)
            log_error "Unknown option: $1"
            exit 1
            ;;
    esac
done

# Check for -i flag (interactive app selection)
INTERACTIVE_SELECT=false
if [[ "$2" == "-i" ]] || [[ "$3" == "-i" ]]; then
    INTERACTIVE_SELECT=true
fi

case "${1:-help}" in
    # General
    setup)          cmd_setup ;;
    list|ls)        cmd_list ;;
    create)         cmd_create "$2" ;;
    destroy|delete) cmd_destroy "$2" ;;

    # Info
    info|status)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            [ -n "$app" ] && cmd_info "$app"
        else
            cmd_info "$2"
        fi
        ;;
    logs)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            [ -n "$app" ] && cmd_logs "$app" "$3"
        else
            cmd_logs "$2" "$3"
        fi
        ;;
    logs:follow|lf)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            [ -n "$app" ] && cmd_logs_follow "$app"
        else
            cmd_logs_follow "$2"
        fi
        ;;

    # Config
    config)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            [ -n "$app" ] && cmd_config "$app"
        else
            cmd_config "$2"
        fi
        ;;
    config:set)     shift; cmd_config_set "$@" ;;
    config:unset)   shift; cmd_config_unset "$@" ;;

    # Process
    restart)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            [ -n "$app" ] && cmd_restart "$app"
        else
            cmd_restart "$2"
        fi
        ;;
    start)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            [ -n "$app" ] && cmd_start "$app"
        else
            cmd_start "$2"
        fi
        ;;
    stop)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            [ -n "$app" ] && cmd_stop "$app"
        else
            cmd_stop "$2"
        fi
        ;;
    scale)          shift; cmd_scale "$@" ;;
    shell|sh)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            [ -n "$app" ] && cmd_shell "$app"
        else
            cmd_shell "$2"
        fi
        ;;

    # Deploy
    deploy|push)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            if [ -n "$app" ]; then
                branch=$(select_branch)
                [ -n "$branch" ] && cmd_deploy "$app" "$branch"
            fi
        else
            cmd_deploy "$2" "$3"
        fi
        ;;
    rollback|rb)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            [ -n "$app" ] && cmd_rollback "$app" "$3"
        else
            cmd_rollback "$2" "$3"
        fi
        ;;
    releases)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            [ -n "$app" ] && cmd_releases "$app"
        else
            cmd_releases "$2"
        fi
        ;;

    # Deploy Locks
    lock)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            [ -n "$app" ] && cmd_lock "$app" "$3"
        else
            cmd_lock "$2" "$3"
        fi
        ;;
    unlock)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            [ -n "$app" ] && cmd_unlock "$app"
        else
            cmd_unlock "$2"
        fi
        ;;
    lock:status)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            [ -n "$app" ] && cmd_lock_status "$app"
        else
            cmd_lock_status "$2"
        fi
        ;;

    # SSL & Domains
    ssl)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            [ -n "$app" ] && cmd_ssl "$app" "$3"
        else
            cmd_ssl "$2" "$3"
        fi
        ;;
    domains)        shift; cmd_domains "$@" ;;

    # Database
    db)             shift; cmd_db "$@" ;;

    # Run
    run)            shift; cmd_run "$@" ;;

    # Aliases
    alias)          shift; cmd_alias "$@" ;;

    # Interactive mode
    i|interactive)  cmd_interactive ;;
    pick)           cmd_pick ;;

    # Help
    help)           cmd_help ;;

    *)
        log_error "Unknown command: $1"
        echo "Run 'dokku-cli help' for usage"
        exit 1
        ;;
esac
