#!/bin/bash
# ═══════════════════════════════════════════════════════════════════════════════
# dokku-cli - Developer CLI for Dokku deployments
# ═══════════════════════════════════════════════════════════════════════════════
#
# A developer-friendly CLI wrapper for common Dokku operations.
# Simplifies app management, logging, deployment, and debugging.
#
# Installation:
#   chmod +x dokku-cli
#   sudo mv dokku-cli /usr/local/bin/
#
# Configuration:
#   Set DOKKU_HOST and SSH_KEY in your shell profile, or use a config file.
#
# ═══════════════════════════════════════════════════════════════════════════════

set -e

# ─────────────────────────────────────────────────────────────────────────────
# Configuration
# ─────────────────────────────────────────────────────────────────────────────

# Load config from file if exists
CONFIG_FILE="${HOME}/.dokku-cli"
if [ -f "$CONFIG_FILE" ]; then
    source "$CONFIG_FILE"
fi

# Configuration (can be overridden by environment or config file)
DOKKU_HOST="${DOKKU_HOST:-dokku.yourdomain.com}"
SSH_KEY="${SSH_KEY:-${HOME}/.ssh/dokku_deploy}"
BASE_DOMAIN="${BASE_DOMAIN:-yourdomain.com}"

# Output format (set via --json or --quiet flags)
OUTPUT_FORMAT="${OUTPUT_FORMAT:-text}"
QUIET_MODE="${QUIET_MODE:-false}"

# ─────────────────────────────────────────────────────────────────────────────
# Colors and formatting
# ─────────────────────────────────────────────────────────────────────────────

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

log_info()    { echo -e "${BLUE}ℹ${NC} $1"; }
log_success() { echo -e "${GREEN}✓${NC} $1"; }
log_warning() { echo -e "${YELLOW}⚠${NC} $1"; }
log_error()   { echo -e "${RED}✗${NC} $1"; }
log_header()  { echo -e "\n${BOLD}${CYAN}$1${NC}\n"; }

# ─────────────────────────────────────────────────────────────────────────────
# SSH helper
# ─────────────────────────────────────────────────────────────────────────────

dokku_ssh() {
    if [ -f "$SSH_KEY" ]; then
        ssh -i "$SSH_KEY" "dokku@$DOKKU_HOST" "$@"
    else
        ssh "dokku@$DOKKU_HOST" "$@"
    fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Interactive mode helpers
# ─────────────────────────────────────────────────────────────────────────────

check_fzf() {
    if ! command -v fzf &>/dev/null; then
        log_error "Interactive mode requires 'fzf' (fuzzy finder)"
        echo ""
        echo "Install fzf:"
        echo "  macOS:   brew install fzf"
        echo "  Ubuntu:  sudo apt install fzf"
        echo "  Fedora:  sudo dnf install fzf"
        echo "  Arch:    sudo pacman -S fzf"
        echo ""
        echo "Or visit: https://github.com/junegunn/fzf#installation"
        exit 1
    fi
}

# Show a menu with fzf, filtering out separator lines
show_menu() {
    local header="$1"
    local options="$2"
    local prompt="${3:-Select > }"

    echo "$options" | grep -v '^─' | fzf \
        --header="$header" \
        --height=80% \
        --border \
        --prompt="$prompt" \
        --no-info
}

# Confirm before quitting
confirm_quit() {
    echo ""
    read -p "Exit interactive mode? (y/N): " confirm
    [[ "$confirm" =~ ^[Yy] ]]
}

# Wait for user to press Enter
press_enter() {
    echo ""
    read -p "Press Enter to continue..."
}

# Get app info for fzf preview
get_app_preview() {
    local app="$1"

    echo -e "${BOLD}═══ $app ═══${NC}"
    echo ""

    # Status
    local status=$(dokku_ssh ps:report "$app" 2>/dev/null | grep -E "running|stopped" | head -1 || echo "unknown")
    echo -e "${BOLD}Status:${NC} $status"

    # URL
    echo -e "${BOLD}URL:${NC} https://$app.$BASE_DOMAIN"

    # Last deploy (from GIT_REV)
    local git_rev=$(dokku_ssh config:get "$app" GIT_REV 2>/dev/null | head -c 7)
    [ -n "$git_rev" ] && echo -e "${BOLD}Commit:${NC} $git_rev"

    # Resources
    local resources=$(dokku_ssh resource:report "$app" 2>/dev/null | grep -E "memory|cpu" | head -2)
    if [ -n "$resources" ]; then
        echo ""
        echo -e "${BOLD}Resources:${NC}"
        echo "$resources" | sed 's/^/  /'
    fi

    # Lock status
    local locked=$(dokku_ssh config:get "$app" DEPLOY_LOCKED 2>/dev/null)
    if [ "$locked" == "true" ]; then
        local reason=$(dokku_ssh config:get "$app" DEPLOY_LOCK_REASON 2>/dev/null)
        echo ""
        echo -e "${RED}LOCKED:${NC} $reason"
    fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Resolve app alias
# ─────────────────────────────────────────────────────────────────────────────

resolve_alias() {
    local name="$1"
    local alias_var="ALIAS_$(echo "$name" | tr '[:lower:]' '[:upper:]')"

    # Check if alias exists in config
    if [ -f "$CONFIG_FILE" ]; then
        local resolved=$(grep "^$alias_var=" "$CONFIG_FILE" 2>/dev/null | cut -d'=' -f2 | tr -d '"')
        if [ -n "$resolved" ]; then
            echo "$resolved"
            return
        fi
    fi
    echo "$name"
}

# ─────────────────────────────────────────────────────────────────────────────
# Get app name (from argument or current git repo)
# ─────────────────────────────────────────────────────────────────────────────

get_app_name() {
    local name=""
    if [ -n "$1" ]; then
        name="$1"
    elif git rev-parse --is-inside-work-tree &>/dev/null; then
        name=$(basename "$(git rev-parse --show-toplevel)")
    else
        log_error "No app name provided and not in a git repository"
        exit 1
    fi

    # Resolve alias
    resolve_alias "$name"
}

# ─────────────────────────────────────────────────────────────────────────────
# Commands
# ─────────────────────────────────────────────────────────────────────────────

cmd_list() {
    if [ "$OUTPUT_FORMAT" == "json" ]; then
        # JSON output
        local apps=$(dokku_ssh apps:list 2>/dev/null | tail -n +2)
        echo '{"apps":['
        local first=true
        for app in $apps; do
            [ "$first" = true ] && first=false || echo ","
            echo -n "\"$app\""
        done
        echo ']}'
    elif [ "$QUIET_MODE" == "true" ]; then
        # Quiet mode - just app names
        dokku_ssh apps:list 2>/dev/null | tail -n +2
    else
        log_header "All Apps"
        dokku_ssh apps:list
    fi
}

cmd_info() {
    local APP=$(get_app_name "$1")
    log_header "App Info: $APP"

    echo -e "${BOLD}Status${NC}"
    dokku_ssh ps:report "$APP" 2>/dev/null || echo "  Not running"

    echo ""
    echo -e "${BOLD}Domains${NC}"
    dokku_ssh domains:report "$APP" 2>/dev/null || echo "  No domains"

    echo ""
    echo -e "${BOLD}SSL${NC}"
    dokku_ssh letsencrypt:list 2>/dev/null | grep -E "^$APP " || echo "  No SSL certificate"

    echo ""
    echo -e "${BOLD}Resources${NC}"
    dokku_ssh resource:report "$APP" 2>/dev/null || echo "  Default resources"
}

cmd_logs() {
    local APP=$(get_app_name "$1")
    local NUM="${2:---num 100}"
    log_info "Logs for $APP"
    dokku_ssh logs "$APP" $NUM
}

cmd_logs_follow() {
    local APP=$(get_app_name "$1")
    log_info "Following logs for $APP (Ctrl+C to stop)"
    dokku_ssh logs "$APP" -t
}

cmd_config() {
    local APP=$(get_app_name "$1")
    log_header "Environment Variables: $APP"
    dokku_ssh config:show "$APP"
}

cmd_config_set() {
    local APP=$(get_app_name "$1")
    shift
    if [ $# -eq 0 ]; then
        log_error "Usage: dokku-cli config:set [app] KEY=value [KEY2=value2 ...]"
        exit 1
    fi
    log_info "Setting config for $APP..."
    dokku_ssh config:set "$APP" "$@"
    log_success "Config updated"
}

cmd_config_unset() {
    local APP=$(get_app_name "$1")
    shift
    if [ $# -eq 0 ]; then
        log_error "Usage: dokku-cli config:unset [app] KEY [KEY2 ...]"
        exit 1
    fi
    log_info "Unsetting config for $APP..."
    dokku_ssh config:unset "$APP" "$@"
    log_success "Config updated"
}

cmd_shell() {
    local APP=$(get_app_name "$1")
    log_info "Opening shell for $APP..."
    # Need -t for interactive TTY
    if [ -f "$SSH_KEY" ]; then
        ssh -t -i "$SSH_KEY" "dokku@$DOKKU_HOST" enter "$APP" web
    else
        ssh -t "dokku@$DOKKU_HOST" enter "$APP" web
    fi
}

cmd_run() {
    local APP=$(get_app_name "$1")
    shift
    if [ $# -eq 0 ]; then
        log_error "Usage: dokku-cli run [app] <command>"
        exit 1
    fi
    log_info "Running command in $APP..."
    dokku_ssh run "$APP" "$@"
}

cmd_restart() {
    local APP=$(get_app_name "$1")
    log_info "Restarting $APP..."
    dokku_ssh ps:restart "$APP"
    log_success "Restarted"
}

cmd_stop() {
    local APP=$(get_app_name "$1")
    log_warning "Stopping $APP..."
    dokku_ssh ps:stop "$APP"
    log_success "Stopped"
}

cmd_start() {
    local APP=$(get_app_name "$1")
    log_info "Starting $APP..."
    dokku_ssh ps:start "$APP"
    log_success "Started"
}

cmd_scale() {
    local APP=$(get_app_name "$1")
    shift
    if [ $# -eq 0 ]; then
        log_header "Current Scale: $APP"
        dokku_ssh ps:scale "$APP"
    else
        log_info "Scaling $APP..."
        dokku_ssh ps:scale "$APP" "$@"
        log_success "Scaled"
    fi
}

cmd_deploy() {
    local APP=$(get_app_name "$1")
    local BRANCH="${2:-HEAD}"

    log_header "Deploying $APP"

    # Check if we're in a git repo
    if ! git rev-parse --is-inside-work-tree &>/dev/null; then
        log_error "Not in a git repository"
        exit 1
    fi

    # Check for uncommitted changes
    if ! git diff-index --quiet HEAD -- 2>/dev/null; then
        log_warning "You have uncommitted changes"
        read -p "Continue anyway? (y/N): " confirm
        if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
            exit 1
        fi
    fi

    # Setup remote
    log_info "Configuring git remote..."
    git remote add dokku "dokku@$DOKKU_HOST:$APP" 2>/dev/null || \
    git remote set-url dokku "dokku@$DOKKU_HOST:$APP"

    # Deploy
    log_info "Pushing to Dokku..."
    if [ -f "$SSH_KEY" ]; then
        GIT_SSH_COMMAND="ssh -i $SSH_KEY" git push dokku "$BRANCH:main" --force
    else
        git push dokku "$BRANCH:main" --force
    fi

    log_success "Deployed!"
    echo ""
    log_info "URL: https://$APP.$BASE_DOMAIN"
}

cmd_rollback() {
    local APP=$(get_app_name "$1")
    local TARGET="$2"

    # Get release history
    local HISTORY_B64=$(dokku_ssh config:get "$APP" RELEASE_HISTORY_B64 2>/dev/null)

    if [ -z "$HISTORY_B64" ]; then
        log_error "No release history found for $APP"
        log_info "Deploy the app using the GitHub workflow to enable release tracking"
        return 1
    fi

    # Decode history
    local HISTORY=$(echo "$HISTORY_B64" | base64 -d 2>/dev/null)
    if [ -z "$HISTORY" ] || ! echo "$HISTORY" | jq . >/dev/null 2>&1; then
        log_error "Release history is corrupted"
        return 1
    fi

    local RELEASE_COUNT=$(echo "$HISTORY" | jq 'length')

    if [ "$RELEASE_COUNT" -lt 2 ]; then
        log_error "Not enough releases to rollback (need at least 2)"
        return 1
    fi

    # If no target specified, show releases and prompt
    if [ -z "$TARGET" ]; then
        log_header "Available Releases for $APP"
        echo ""
        echo "$HISTORY" | jq -r '.[] | "  v\(.version)\t\(.short)\t\(.timestamp | split("T")[0])\t\(.actor)\t\(.message[0:50])"' | \
            column -t -s $'\t'
        echo ""

        # Default to previous release (index 1)
        local PREV_VERSION=$(echo "$HISTORY" | jq -r '.[1].version')
        local PREV_SHA=$(echo "$HISTORY" | jq -r '.[1].short')

        read -p "Rollback to version [v$PREV_VERSION]: " TARGET
        [ -z "$TARGET" ] && TARGET="$PREV_VERSION"
    fi

    # Remove 'v' prefix if present
    TARGET="${TARGET#v}"

    # Find the target release
    local TARGET_SHA=""
    local TARGET_MSG=""

    # Check if target is a version number or SHA
    if [[ "$TARGET" =~ ^[0-9]+$ ]]; then
        # Version number
        TARGET_SHA=$(echo "$HISTORY" | jq -r ".[] | select(.version == $TARGET) | .sha")
        TARGET_MSG=$(echo "$HISTORY" | jq -r ".[] | select(.version == $TARGET) | .message")
    else
        # Assume it's a SHA (partial or full)
        TARGET_SHA=$(echo "$HISTORY" | jq -r ".[] | select(.sha | startswith(\"$TARGET\") or .short == \"$TARGET\") | .sha" | head -1)
        TARGET_MSG=$(echo "$HISTORY" | jq -r ".[] | select(.sha | startswith(\"$TARGET\") or .short == \"$TARGET\") | .message" | head -1)
    fi

    if [ -z "$TARGET_SHA" ] || [ "$TARGET_SHA" == "null" ]; then
        log_error "Release not found: $TARGET"
        log_info "Use 'dokku-cli releases $APP' to see available releases"
        return 1
    fi

    echo ""
    log_warning "Rolling back $APP to: ${TARGET_SHA:0:7}"
    [ -n "$TARGET_MSG" ] && echo "  Commit: $TARGET_MSG"
    echo ""
    read -p "Continue? [y/N]: " CONFIRM

    if [[ "$CONFIRM" =~ ^[Yy] ]]; then
        log_info "Triggering rollback deployment..."

        # Use git:from-archive or ps:rebuild with the target SHA
        # The best way is to re-deploy via git
        if dokku_ssh git:from-image "$APP" "dokku/$APP:$TARGET_SHA" 2>/dev/null; then
            log_success "Rollback complete!"
        else
            # Fallback: instruct user to use git push
            log_warning "Automatic rollback not available"
            echo ""
            echo "To rollback manually, run from your local repo:"
            echo ""
            echo "  git push dokku $TARGET_SHA:main --force"
            echo ""
            echo "Or trigger a new deployment from GitHub with that commit."
        fi
    else
        log_info "Rollback cancelled"
    fi
}

cmd_releases() {
    local APP=$(get_app_name "$1")
    local FORMAT="${2:-table}"  # table or json

    log_header "Releases: $APP"

    # Get current release info
    local CURRENT_VERSION=$(dokku_ssh config:get "$APP" RELEASE_VERSION 2>/dev/null)
    local CURRENT_SHA=$(dokku_ssh config:get "$APP" RELEASE_SHA 2>/dev/null)
    local CURRENT_TS=$(dokku_ssh config:get "$APP" RELEASE_TIMESTAMP 2>/dev/null)
    local CURRENT_ACTOR=$(dokku_ssh config:get "$APP" RELEASE_ACTOR 2>/dev/null)

    if [ -z "$CURRENT_VERSION" ]; then
        echo ""
        echo -e "${YELLOW}No release tracking enabled for this app.${NC}"
        echo ""
        echo "Release tracking is automatic when deploying via GitHub workflow."
        echo "To enable, push to main/staging/develop branch."
        echo ""

        # Fall back to basic git info
        echo -e "${BOLD}Current Deployment:${NC}"
        local git_rev=$(dokku_ssh config:get "$APP" GIT_REV 2>/dev/null)
        if [ -n "$git_rev" ]; then
            echo "  Commit: ${git_rev:0:7}"
        else
            echo "  No deployment info available"
        fi
        return 0
    fi

    echo ""
    echo -e "${BOLD}Current Release:${NC} v$CURRENT_VERSION"
    echo "  Commit:    ${CURRENT_SHA:0:7}"
    echo "  Deployed:  $CURRENT_TS"
    echo "  By:        $CURRENT_ACTOR"
    echo ""

    # Get release history
    local HISTORY_B64=$(dokku_ssh config:get "$APP" RELEASE_HISTORY_B64 2>/dev/null)

    if [ -n "$HISTORY_B64" ]; then
        local HISTORY=$(echo "$HISTORY_B64" | base64 -d 2>/dev/null)

        if [ -n "$HISTORY" ] && echo "$HISTORY" | jq . >/dev/null 2>&1; then
            if [ "$FORMAT" == "json" ]; then
                echo "$HISTORY" | jq .
            else
                echo -e "${BOLD}Release History:${NC}"
                echo ""
                printf "  %-8s %-9s %-12s %-15s %s\n" "VERSION" "COMMIT" "DATE" "DEPLOYED BY" "MESSAGE"
                echo "  ─────────────────────────────────────────────────────────────────────────────"

                echo "$HISTORY" | jq -r '.[] | "\(.version)\t\(.short)\t\(.timestamp | split("T")[0])\t\(.actor)\t\(.message[0:40])"' | \
                while IFS=$'\t' read -r ver sha date actor msg; do
                    if [ "$ver" == "$CURRENT_VERSION" ]; then
                        printf "  ${GREEN}v%-7s %-9s %-12s %-15s %s${NC}\n" "$ver" "$sha" "$date" "$actor" "$msg"
                    else
                        printf "  v%-7s %-9s %-12s %-15s %s\n" "$ver" "$sha" "$date" "$actor" "$msg"
                    fi
                done

                echo ""
                echo "To rollback: dokku-cli rollback $APP [version]"
            fi
        fi
    fi
}

cmd_create() {
    local APP="$1"
    if [ -z "$APP" ]; then
        log_error "Usage: dokku-cli create <app-name>"
        exit 1
    fi
    log_info "Creating app: $APP"
    dokku_ssh apps:create "$APP"
    log_success "Created"
    log_info "Domain: $APP.$BASE_DOMAIN"
}

cmd_destroy() {
    local APP=$(get_app_name "$1")

    log_warning "This will PERMANENTLY delete $APP and all its data!"
    echo ""
    read -p "Type the app name to confirm: " CONFIRM

    if [ "$CONFIRM" == "$APP" ]; then
        dokku_ssh apps:destroy "$APP" --force
        log_success "Destroyed $APP"
    else
        log_error "Confirmation failed. Aborting."
        exit 1
    fi
}

cmd_ssl() {
    local APP=$(get_app_name "$1")
    local ACTION="${2:-status}"

    case "$ACTION" in
        enable)
            log_info "Enabling SSL for $APP..."
            dokku_ssh letsencrypt:enable "$APP"
            log_success "SSL enabled"
            ;;
        disable)
            log_info "Disabling SSL for $APP..."
            dokku_ssh letsencrypt:disable "$APP"
            log_success "SSL disabled"
            ;;
        status|*)
            log_header "SSL Status: $APP"
            dokku_ssh letsencrypt:list 2>/dev/null | grep -E "^$APP |App " || echo "No SSL certificate"
            ;;
    esac
}

cmd_domains() {
    local APP=$(get_app_name "$1")
    local ACTION="$2"
    shift 2 2>/dev/null || true

    case "$ACTION" in
        add)
            if [ -z "$1" ]; then
                log_error "Usage: dokku-cli domains add [app] <domain>"
                exit 1
            fi
            log_info "Adding domain $1 to $APP..."
            dokku_ssh domains:add "$APP" "$1"
            log_success "Domain added"
            ;;
        remove)
            if [ -z "$1" ]; then
                log_error "Usage: dokku-cli domains remove [app] <domain>"
                exit 1
            fi
            log_info "Removing domain $1 from $APP..."
            dokku_ssh domains:remove "$APP" "$1"
            log_success "Domain removed"
            ;;
        *)
            log_header "Domains: $APP"
            dokku_ssh domains:report "$APP"
            ;;
    esac
}

cmd_db() {
    local APP=$(get_app_name "$1")
    local ACTION="${2:-info}"
    local SERVICE="${3:-postgres}"

    DB_NAME="$SERVICE-$APP"

    case "$ACTION" in
        create)
            log_info "Creating $SERVICE database: $DB_NAME"
            dokku_ssh "$SERVICE:create" "$DB_NAME"
            dokku_ssh "$SERVICE:link" "$DB_NAME" "$APP"
            log_success "Database created and linked"
            ;;
        connect)
            log_info "Connecting to $DB_NAME..."
            dokku_ssh "$SERVICE:connect" "$DB_NAME"
            ;;
        backup)
            local BACKUP_FILE="${APP}-$(date +%Y%m%d_%H%M%S).dump"
            log_info "Backing up $SERVICE database: $DB_NAME"
            log_info "Saving to: $BACKUP_FILE"
            dokku_ssh "$SERVICE:export" "$DB_NAME" > "$BACKUP_FILE"
            log_success "Backup saved: $BACKUP_FILE ($(ls -lh "$BACKUP_FILE" | awk '{print $5}'))"
            ;;
        backup-server)
            # Backup directly to server storage
            TIMESTAMP=$(date +%Y%m%d_%H%M%S)
            BACKUP_DIR="/var/backups/dokku/$SERVICE/$APP"
            BACKUP_FILE="$BACKUP_DIR/${TIMESTAMP}.gz"

            log_info "Backing up $SERVICE database: $DB_NAME"
            log_info "Saving to server: $BACKUP_FILE"

            # Create directory and backup
            ssh -i "$SSH_KEY" "dokku@$DOKKU_HOST" "mkdir -p $BACKUP_DIR"
            dokku_ssh "$SERVICE:export" "$DB_NAME" 2>/dev/null | gzip | \
              ssh -i "$SSH_KEY" "dokku@$DOKKU_HOST" "cat > $BACKUP_FILE"

            if [ $? -eq 0 ]; then
                SIZE=$(ssh -i "$SSH_KEY" "dokku@$DOKKU_HOST" "ls -lh $BACKUP_FILE | awk '{print \$5}'" 2>/dev/null)
                log_success "Backup saved: $BACKUP_FILE ($SIZE)"
            else
                log_error "Backup failed"
            fi
            ;;
        restore)
            local BACKUP_PATH="$SERVICE"  # Third arg is actually the file path
            if [ -z "$BACKUP_PATH" ] || [ "$BACKUP_PATH" == "postgres" ] || [ "$BACKUP_PATH" == "mysql" ]; then
                log_error "Usage: dokku-cli db restore <app> <backup-file>"
                exit 1
            fi

            if [ ! -f "$BACKUP_PATH" ]; then
                log_error "Backup file not found: $BACKUP_PATH"
                exit 1
            fi

            SERVICE="${4:-postgres}"
            DB_NAME="$SERVICE-$APP"

            log_warning "This will replace all data in $DB_NAME with the backup!"
            read -p "Are you sure? (yes/no): " CONFIRM
            if [ "$CONFIRM" != "yes" ]; then
                log_info "Restore cancelled"
                exit 0
            fi

            log_info "Restoring $DB_NAME from $BACKUP_PATH..."
            if [[ "$BACKUP_PATH" == *.gz ]]; then
                gunzip -c "$BACKUP_PATH" | dokku_ssh "$SERVICE:import" "$DB_NAME"
            else
                dokku_ssh "$SERVICE:import" "$DB_NAME" < "$BACKUP_PATH"
            fi
            log_success "Restore complete"
            ;;
        list-backups)
            log_header "Backups for $APP"
            echo ""
            echo "Local backups:"
            ls -lh ${APP}-*.dump 2>/dev/null || echo "  No local backups found"
            echo ""
            echo "Server backups (/var/backups/dokku/):"
            ssh -i "$SSH_KEY" "dokku@$DOKKU_HOST" "
              for service in postgres mysql redis mongo rabbitmq elasticsearch; do
                DIR=\"/var/backups/dokku/\$service/$APP\"
                if [ -d \"\$DIR\" ]; then
                  echo \"  \$service:\"
                  ls -lh \"\$DIR\"/*.gz 2>/dev/null | awk '{print \"    \" \$9 \" (\" \$5 \")\"}' || echo \"    No backups\"
                fi
              done
            " 2>/dev/null || echo "  Unable to list server backups"
            ;;
        info|*)
            log_header "Database: $DB_NAME"
            dokku_ssh "$SERVICE:info" "$DB_NAME" 2>/dev/null || echo "Database not found"
            ;;
    esac
}

cmd_lock() {
    local APP=$(get_app_name "$1")
    local REASON="${2:-Manual lock via CLI}"

    # Check if already locked
    LOCKED=$(dokku_ssh config:get "$APP" DEPLOY_LOCKED 2>/dev/null || echo "false")
    if [ "$LOCKED" == "true" ]; then
        EXISTING_REASON=$(dokku_ssh config:get "$APP" DEPLOY_LOCK_REASON 2>/dev/null)
        log_warning "$APP is already locked"
        echo "  Reason: $EXISTING_REASON"
        return 0
    fi

    TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    LOCKED_BY="${USER:-$(whoami)}"

    log_warning "Locking $APP..."
    dokku_ssh config:set --no-restart "$APP" \
        DEPLOY_LOCKED=true \
        "DEPLOY_LOCK_REASON=$REASON" \
        "DEPLOY_LOCK_BY=$LOCKED_BY" \
        "DEPLOY_LOCK_AT=$TIMESTAMP"

    log_success "Locked! Deployments are now blocked."
    echo "  Reason: $REASON"
}

cmd_unlock() {
    local APP=$(get_app_name "$1")

    # Check if locked
    LOCKED=$(dokku_ssh config:get "$APP" DEPLOY_LOCKED 2>/dev/null || echo "false")
    if [ "$LOCKED" != "true" ]; then
        log_info "$APP is not locked"
        return 0
    fi

    PREV_REASON=$(dokku_ssh config:get "$APP" DEPLOY_LOCK_REASON 2>/dev/null)
    PREV_BY=$(dokku_ssh config:get "$APP" DEPLOY_LOCK_BY 2>/dev/null)

    log_info "Unlocking $APP..."
    dokku_ssh config:unset --no-restart "$APP" \
        DEPLOY_LOCKED \
        DEPLOY_LOCK_REASON \
        DEPLOY_LOCK_BY \
        DEPLOY_LOCK_AT

    log_success "Unlocked! Deployments are now allowed."
    echo "  Previously locked by: $PREV_BY"
    echo "  Reason was: $PREV_REASON"
}

cmd_lock_status() {
    local APP=$(get_app_name "$1")

    LOCKED=$(dokku_ssh config:get "$APP" DEPLOY_LOCKED 2>/dev/null || echo "false")

    log_header "Lock Status: $APP"

    if [ "$LOCKED" == "true" ]; then
        REASON=$(dokku_ssh config:get "$APP" DEPLOY_LOCK_REASON 2>/dev/null)
        LOCKED_BY=$(dokku_ssh config:get "$APP" DEPLOY_LOCK_BY 2>/dev/null)
        LOCKED_AT=$(dokku_ssh config:get "$APP" DEPLOY_LOCK_AT 2>/dev/null)

        echo -e "${RED}LOCKED${NC} - Deployments are blocked"
        echo ""
        echo "  Reason:    $REASON"
        echo "  Locked by: $LOCKED_BY"
        echo "  Locked at: $LOCKED_AT"
    else
        echo -e "${GREEN}UNLOCKED${NC} - Deployments are allowed"
    fi
}

cmd_setup() {
    log_header "Dokku CLI Setup"

    echo "This will create a configuration file at ~/.dokku-cli"
    echo ""

    read -p "Dokku host [$DOKKU_HOST]: " input_host
    DOKKU_HOST="${input_host:-$DOKKU_HOST}"

    read -p "SSH key path [$SSH_KEY]: " input_key
    SSH_KEY="${input_key:-$SSH_KEY}"

    read -p "Base domain [$BASE_DOMAIN]: " input_domain
    BASE_DOMAIN="${input_domain:-$BASE_DOMAIN}"

    cat > "$CONFIG_FILE" << EOF
# Dokku CLI Configuration
DOKKU_HOST="$DOKKU_HOST"
SSH_KEY="$SSH_KEY"
BASE_DOMAIN="$BASE_DOMAIN"

# App Aliases (format: ALIAS_NAME="actual-app-name")
# Example:
# ALIAS_PROD="myapp"
# ALIAS_STG="myapp-staging"
EOF

    log_success "Configuration saved to $CONFIG_FILE"

    echo ""
    log_info "Testing connection..."
    if dokku_ssh version 2>/dev/null; then
        log_success "Connected to Dokku!"
    else
        log_error "Could not connect to Dokku"
        log_info "Check your DOKKU_HOST and SSH_KEY settings"
    fi
}

cmd_doctor() {
    log_header "Dokku CLI Doctor"

    echo "Checking local environment..."
    echo ""

    # Check local tools
    echo -e "${BOLD}Local Tools${NC}"

    # fzf
    if command -v fzf &>/dev/null; then
        echo -e "  ${GREEN}✓${NC} fzf $(fzf --version 2>/dev/null | head -1)"
    else
        echo -e "  ${YELLOW}○${NC} fzf (not installed - interactive mode unavailable)"
        echo "      Install: brew install fzf (macOS) or apt install fzf (Linux)"
    fi

    # git
    if command -v git &>/dev/null; then
        echo -e "  ${GREEN}✓${NC} git $(git --version | cut -d' ' -f3)"
    else
        echo -e "  ${RED}✗${NC} git (required for deploy)"
    fi

    # ssh
    if command -v ssh &>/dev/null; then
        echo -e "  ${GREEN}✓${NC} ssh"
    else
        echo -e "  ${RED}✗${NC} ssh (required)"
    fi

    echo ""
    echo "Checking Dokku server connection..."
    echo ""

    # Test SSH connection
    echo -e "${BOLD}Server Connection${NC}"
    echo "  Host: $DOKKU_HOST"

    if [ -f "$SSH_KEY" ]; then
        echo -e "  SSH Key: ${GREEN}✓${NC} $SSH_KEY"
    else
        echo -e "  SSH Key: ${RED}✗${NC} $SSH_KEY (not found)"
        echo ""
        log_error "Cannot connect to server - SSH key missing"
        return 1
    fi

    # Test connection and get version
    local dokku_version=$(dokku_ssh version 2>/dev/null)
    if [ -n "$dokku_version" ]; then
        echo -e "  Connection: ${GREEN}✓${NC} Connected"
        echo -e "  Dokku Version: $dokku_version"
    else
        echo -e "  Connection: ${RED}✗${NC} Failed"
        echo ""
        log_error "Cannot connect to Dokku server"
        log_info "Check DOKKU_HOST and SSH_KEY settings"
        return 1
    fi

    echo ""
    echo -e "${BOLD}Dokku Plugins${NC}"
    echo ""

    # Check each plugin
    local plugins=$(dokku_ssh plugin:list 2>/dev/null)

    # Core features (always available)
    echo "  Core (built-in):"
    echo -e "    ${GREEN}✓${NC} apps, config, domains, ps, run, enter, releases"
    echo ""

    # SSL - Let's Encrypt
    echo "  SSL/TLS:"
    if echo "$plugins" | grep -q "letsencrypt"; then
        echo -e "    ${GREEN}✓${NC} letsencrypt - SSL certificates available"
    else
        echo -e "    ${YELLOW}○${NC} letsencrypt - Not installed"
        echo "        Install: dokku plugin:install https://github.com/dokku/dokku-letsencrypt.git"
        echo "        Enables: dokku-cli ssl enable/disable"
    fi
    echo ""

    # Databases
    echo "  Databases:"

    # PostgreSQL
    if echo "$plugins" | grep -q "postgres"; then
        echo -e "    ${GREEN}✓${NC} postgres"
    else
        echo -e "    ${YELLOW}○${NC} postgres - Not installed"
        echo "        Install: dokku plugin:install https://github.com/dokku/dokku-postgres.git"
    fi

    # MySQL
    if echo "$plugins" | grep -q "mysql"; then
        echo -e "    ${GREEN}✓${NC} mysql"
    else
        echo -e "    ${CYAN}○${NC} mysql - Not installed (optional)"
    fi

    # Redis
    if echo "$plugins" | grep -q "redis"; then
        echo -e "    ${GREEN}✓${NC} redis"
    else
        echo -e "    ${CYAN}○${NC} redis - Not installed (optional)"
    fi

    # MongoDB
    if echo "$plugins" | grep -q "mongo"; then
        echo -e "    ${GREEN}✓${NC} mongo"
    else
        echo -e "    ${CYAN}○${NC} mongo - Not installed (optional)"
    fi

    # RabbitMQ
    if echo "$plugins" | grep -q "rabbitmq"; then
        echo -e "    ${GREEN}✓${NC} rabbitmq"
    else
        echo -e "    ${CYAN}○${NC} rabbitmq - Not installed (optional)"
    fi

    # Elasticsearch
    if echo "$plugins" | grep -q "elasticsearch"; then
        echo -e "    ${GREEN}✓${NC} elasticsearch"
    else
        echo -e "    ${CYAN}○${NC} elasticsearch - Not installed (optional)"
    fi

    echo ""

    # Other useful plugins
    echo "  Other:"

    # Resource limits
    if echo "$plugins" | grep -q "resource"; then
        echo -e "    ${GREEN}✓${NC} resource - Memory/CPU limits available"
    else
        echo -e "    ${CYAN}○${NC} resource - Not installed (optional)"
        echo "        Install: dokku plugin:install https://github.com/dokku/dokku-resource.git"
    fi

    echo ""
    echo "─────────────────────────────────────────────────────────────────"
    echo ""

    # Summary
    local missing_required=0
    local missing_recommended=0

    if ! echo "$plugins" | grep -q "letsencrypt"; then
        missing_recommended=$((missing_recommended + 1))
    fi
    if ! echo "$plugins" | grep -q "postgres"; then
        missing_recommended=$((missing_recommended + 1))
    fi
    if ! echo "$plugins" | grep -q "resource"; then
        missing_recommended=$((missing_recommended + 1))
    fi

    if [ $missing_recommended -eq 0 ]; then
        echo -e "${GREEN}✓${NC} All recommended plugins installed"
    else
        echo -e "${YELLOW}!${NC} $missing_recommended recommended plugin(s) not installed"
        echo ""
        echo "Quick install (run on Dokku server):"
        echo ""
        if ! echo "$plugins" | grep -q "letsencrypt"; then
            echo "  sudo dokku plugin:install https://github.com/dokku/dokku-letsencrypt.git"
        fi
        if ! echo "$plugins" | grep -q "postgres"; then
            echo "  sudo dokku plugin:install https://github.com/dokku/dokku-postgres.git"
        fi
        if ! echo "$plugins" | grep -q "resource"; then
            echo "  sudo dokku plugin:install https://github.com/dokku/dokku-resource.git"
        fi
    fi

    echo ""

    # Feature availability summary
    echo -e "${BOLD}Feature Availability${NC}"
    echo ""
    echo "  Command               Status"
    echo "  ─────────────────────────────────────────"
    echo -e "  list, info, logs      ${GREEN}Available${NC}"
    echo -e "  config, restart       ${GREEN}Available${NC}"
    echo -e "  deploy, rollback      ${GREEN}Available${NC}"
    echo -e "  shell, run            ${GREEN}Available${NC}"
    echo -e "  lock, unlock          ${GREEN}Available${NC}"
    echo -e "  domains               ${GREEN}Available${NC}"

    if echo "$plugins" | grep -q "letsencrypt"; then
        echo -e "  ssl enable/disable    ${GREEN}Available${NC}"
    else
        echo -e "  ssl enable/disable    ${YELLOW}Unavailable${NC} (needs letsencrypt)"
    fi

    if echo "$plugins" | grep -q "postgres\|mysql\|mongo\|redis"; then
        echo -e "  db commands           ${GREEN}Available${NC}"
    else
        echo -e "  db commands           ${YELLOW}Unavailable${NC} (needs database plugin)"
    fi

    if echo "$plugins" | grep -q "resource"; then
        echo -e "  resource limits       ${GREEN}Available${NC}"
    else
        echo -e "  resource limits       ${YELLOW}Unavailable${NC} (needs resource plugin)"
    fi

    if command -v fzf &>/dev/null; then
        echo -e "  interactive mode      ${GREEN}Available${NC}"
    else
        echo -e "  interactive mode      ${YELLOW}Unavailable${NC} (needs fzf)"
    fi
}

cmd_alias() {
    local ACTION="${1:-list}"
    local ALIAS_NAME="$2"
    local APP_NAME="$3"

    case "$ACTION" in
        list)
            log_header "App Aliases"
            if [ -f "$CONFIG_FILE" ]; then
                local aliases=$(grep "^ALIAS_" "$CONFIG_FILE" 2>/dev/null)
                if [ -n "$aliases" ]; then
                    echo "$aliases" | while read line; do
                        local name=$(echo "$line" | cut -d'=' -f1 | sed 's/ALIAS_//' | tr '[:upper:]' '[:lower:]')
                        local app=$(echo "$line" | cut -d'=' -f2 | tr -d '"')
                        echo "  $name -> $app"
                    done
                else
                    echo "  No aliases configured"
                    echo ""
                    echo "  Add with: dokku-cli alias add <name> <app>"
                fi
            else
                log_error "Config file not found. Run 'dokku-cli setup' first."
            fi
            ;;
        add|set)
            if [ -z "$ALIAS_NAME" ] || [ -z "$APP_NAME" ]; then
                log_error "Usage: dokku-cli alias add <name> <app>"
                exit 1
            fi
            local alias_var="ALIAS_$(echo "$ALIAS_NAME" | tr '[:lower:]' '[:upper:]')"

            # Remove existing alias if present
            if [ -f "$CONFIG_FILE" ]; then
                sed -i.bak "/^$alias_var=/d" "$CONFIG_FILE"
                rm -f "${CONFIG_FILE}.bak"
            fi

            # Add new alias
            echo "$alias_var=\"$APP_NAME\"" >> "$CONFIG_FILE"
            log_success "Alias '$ALIAS_NAME' -> '$APP_NAME' added"
            log_info "Now you can use: dokku-cli logs $ALIAS_NAME"
            ;;
        remove|rm|delete)
            if [ -z "$ALIAS_NAME" ]; then
                log_error "Usage: dokku-cli alias remove <name>"
                exit 1
            fi
            local alias_var="ALIAS_$(echo "$ALIAS_NAME" | tr '[:lower:]' '[:upper:]')"

            if [ -f "$CONFIG_FILE" ]; then
                if grep -q "^$alias_var=" "$CONFIG_FILE"; then
                    sed -i.bak "/^$alias_var=/d" "$CONFIG_FILE"
                    rm -f "${CONFIG_FILE}.bak"
                    log_success "Alias '$ALIAS_NAME' removed"
                else
                    log_error "Alias '$ALIAS_NAME' not found"
                fi
            fi
            ;;
        *)
            log_error "Unknown alias action: $ACTION"
            echo "Usage: dokku-cli alias [list|add|remove] [name] [app]"
            exit 1
            ;;
    esac
}

# ─────────────────────────────────────────────────────────────────────────────
# Interactive Mode Commands
# ─────────────────────────────────────────────────────────────────────────────

# Pick an app interactively
cmd_pick() {
    check_fzf

    local apps=$(dokku_ssh apps:list 2>/dev/null | tail -n +2)

    if [ -z "$apps" ]; then
        log_error "No apps found"
        exit 1
    fi

    # Create a temp script for preview (fzf runs in subshell)
    local preview_script=$(mktemp)
    cat > "$preview_script" << 'PREVIEW_EOF'
#!/bin/bash
APP="$1"
CONFIG_FILE="${HOME}/.dokku-cli"
[ -f "$CONFIG_FILE" ] && source "$CONFIG_FILE"
DOKKU_HOST="${DOKKU_HOST:-dokku.yourdomain.com}"
SSH_KEY="${SSH_KEY:-${HOME}/.ssh/dokku_deploy}"
BASE_DOMAIN="${BASE_DOMAIN:-yourdomain.com}"

dokku_ssh() {
    if [ -f "$SSH_KEY" ]; then
        ssh -i "$SSH_KEY" "dokku@$DOKKU_HOST" "$@" 2>/dev/null
    else
        ssh "dokku@$DOKKU_HOST" "$@" 2>/dev/null
    fi
}

echo "═══ $APP ═══"
echo ""
echo "URL: https://$APP.$BASE_DOMAIN"
echo ""

# Quick status check
STATUS=$(dokku_ssh ps:report "$APP" 2>/dev/null | grep -i "status" | head -1)
[ -n "$STATUS" ] && echo "$STATUS"

# Process count
PROCS=$(dokku_ssh ps:report "$APP" 2>/dev/null | grep -i "running" | head -1)
[ -n "$PROCS" ] && echo "$PROCS"

# Lock status
LOCKED=$(dokku_ssh config:get "$APP" DEPLOY_LOCKED 2>/dev/null)
if [ "$LOCKED" == "true" ]; then
    REASON=$(dokku_ssh config:get "$APP" DEPLOY_LOCK_REASON 2>/dev/null)
    echo ""
    echo "⚠️  LOCKED: $REASON"
fi
PREVIEW_EOF
    chmod +x "$preview_script"

    local selected=$(echo "$apps" | fzf \
        --header="Select an app (ESC to cancel)" \
        --preview="$preview_script {}" \
        --preview-window=right:50%:wrap \
        --height=80% \
        --border \
        --prompt="App > ")

    rm -f "$preview_script"

    [ -n "$selected" ] && echo "$selected"
}

# Select action for an app
select_action() {
    local app="$1"

    local actions="View Logs
Follow Logs (live)
Restart
View Config
Set Config Variable
Scale Processes
Open Shell
─────────────────
Deploy (from branch)
Rollback
View Releases
─────────────────
Lock Deployments
Unlock Deployments
Check Lock Status
─────────────────
Database →
SSL →
Domains →
─────────────────
Destroy App
─────────────────
← Back to apps
✕ Quit"

    show_menu "$app" "$actions" "Action > "
}

# Select git branch
select_branch() {
    check_fzf

    if ! git rev-parse --is-inside-work-tree &>/dev/null; then
        log_error "Not in a git repository"
        return 1
    fi

    local branches=$(git branch -a 2>/dev/null | \
        sed 's/^[* ]*//' | \
        sed 's/remotes\/origin\///' | \
        grep -v "HEAD" | \
        sort -u)

    echo "$branches" | fzf \
        --header="Select branch to deploy" \
        --preview="git log --oneline -10 {} 2>/dev/null || echo 'No commits'" \
        --preview-window=right:50%:wrap \
        --height=80% \
        --border \
        --prompt="Branch > "
}

# Database operations submenu
interactive_db() {
    local app="$1"

    while true; do
        local actions="Connect to Database
View Database Info
Backup to Local File
Backup to Server
Restore from Backup
List All Backups
─────────────────
← Back"

        local action=$(show_menu "$app - Database" "$actions" "DB > ")
        [ -z "$action" ] && return  # ESC pressed

        case "$action" in
            "← Back") return ;;
            "Connect to Database")
                cmd_db "$app" connect
                ;;
            "View Database Info")
                cmd_db "$app" info
                press_enter
                ;;
            "Backup to Local File")
                cmd_db "$app" backup
                press_enter
                ;;
            "Backup to Server")
                cmd_db "$app" backup-server
                press_enter
                ;;
            "Restore from Backup")
                echo ""
                log_info "Enter backup file path:"
                read -p "> " backup_file
                if [ -n "$backup_file" ]; then
                    cmd_db "$app" restore "$backup_file"
                    press_enter
                fi
                ;;
            "List All Backups")
                cmd_db "$app" list-backups
                press_enter
                ;;
        esac
    done
}

# SSL operations submenu
interactive_ssl() {
    local app="$1"

    while true; do
        local actions="View SSL Status
Enable SSL
Disable SSL
─────────────────
← Back"

        local action=$(show_menu "$app - SSL" "$actions" "SSL > ")
        [ -z "$action" ] && return  # ESC pressed

        case "$action" in
            "← Back") return ;;
            "View SSL Status")
                cmd_ssl "$app" status
                press_enter
                ;;
            "Enable SSL")
                cmd_ssl "$app" enable
                press_enter
                ;;
            "Disable SSL")
                cmd_ssl "$app" disable
                press_enter
                ;;
        esac
    done
}

# Domain operations submenu
interactive_domains() {
    local app="$1"

    while true; do
        local actions="List Domains
Add Domain
Remove Domain
─────────────────
← Back"

        local action=$(show_menu "$app - Domains" "$actions" "Domain > ")
        [ -z "$action" ] && return  # ESC pressed

        case "$action" in
            "← Back") return ;;
            "List Domains")
                cmd_domains "$app"
                press_enter
                ;;
            "Add Domain")
                echo ""
                log_info "Enter domain to add:"
                read -p "> " domain
                if [ -n "$domain" ]; then
                    cmd_domains "$app" add "$domain"
                    press_enter
                fi
                ;;
            "Remove Domain")
                # Show current domains first
                echo ""
                log_info "Current domains:"
                dokku_ssh domains:report "$app" 2>/dev/null | grep -i vhost || echo "  No custom domains"
                echo ""
                log_info "Enter domain to remove:"
                read -p "> " domain
                if [ -n "$domain" ]; then
                    cmd_domains "$app" remove "$domain"
                    press_enter
                fi
                ;;
        esac
    done
}

# Main interactive mode
cmd_interactive() {
    check_fzf

    log_info "Loading apps..."

    local app=""
    local action=""
    local quit_requested=false

    # Outer loop: app selection
    while true; do
        echo ""  # Clear line before fzf
        app=$(cmd_pick)

        # ESC or empty = confirm exit
        if [ -z "$app" ]; then
            if confirm_quit; then
                break
            fi
            continue
        fi

        # Inner loop: stay in app context until Back or Quit
        while true; do
            action=$(select_action "$app")

            # ESC pressed - treat as back to apps
            if [ -z "$action" ]; then
                break
            fi

            case "$action" in
                "← Back to apps")
                    break  # Back to app selection
                    ;;
                "✕ Quit")
                    if confirm_quit; then
                        quit_requested=true
                        break
                    fi
                    ;;
                "View Logs")
                    cmd_logs "$app"
                    press_enter
                    ;;
                "Follow Logs (live)")
                    log_info "Press Ctrl+C to stop following logs"
                    cmd_logs_follow "$app"
                    ;;
                "Restart")
                    cmd_restart "$app"
                    ;;
                "View Config")
                    cmd_config "$app"
                    press_enter
                    ;;
                "Set Config Variable")
                    echo ""
                    echo "Enter KEY=value (or multiple: KEY1=val1 KEY2=val2):"
                    read -p "> " config_input
                    if [ -n "$config_input" ]; then
                        cmd_config_set "$app" $config_input
                    fi
                    ;;
                "Scale Processes")
                    echo ""
                    echo "Current scale:"
                    dokku_ssh ps:scale "$app"
                    echo ""
                    echo "Enter new scale (e.g., web=2 worker=1):"
                    read -p "> " scale_input
                    if [ -n "$scale_input" ]; then
                        cmd_scale "$app" $scale_input
                    fi
                    ;;
                "Open Shell")
                    cmd_shell "$app"
                    ;;
                "Deploy (from branch)")
                    local branch=$(select_branch)
                    if [ -n "$branch" ]; then
                        cmd_deploy "$app" "$branch"
                        press_enter
                    fi
                    ;;
                "Rollback")
                    cmd_rollback "$app"
                    press_enter
                    ;;
                "View Releases")
                    cmd_releases "$app"
                    press_enter
                    ;;
                "Lock Deployments")
                    echo ""
                    echo "Enter lock reason:"
                    read -p "> " reason
                    cmd_lock "$app" "${reason:-Manual lock}"
                    ;;
                "Unlock Deployments")
                    cmd_unlock "$app"
                    ;;
                "Check Lock Status")
                    cmd_lock_status "$app"
                    press_enter
                    ;;
                "Database →")
                    interactive_db "$app"
                    ;;
                "SSL →")
                    interactive_ssl "$app"
                    ;;
                "Domains →")
                    interactive_domains "$app"
                    ;;
                "Destroy App")
                    cmd_destroy "$app"
                    break  # Back to app selection after destroy
                    ;;
            esac
        done

        # Check if quit was requested from inner loop
        if [ "$quit_requested" = true ]; then
            break
        fi
    done

    log_info "Exiting interactive mode"
}

cmd_help() {
    cat << 'EOF'
╔═══════════════════════════════════════════════════════════════════════════════╗
║                              DOKKU CLI                                         ║
║                   Developer tools for Dokku deployments                        ║
╚═══════════════════════════════════════════════════════════════════════════════╝

Usage: dokku-cli [--json|--quiet] <command> [app] [options]

If [app] is not provided, it will be inferred from the current git repository.
You can also use aliases instead of app names (see ALIASES section).

GLOBAL OPTIONS
  --json                     Output in JSON format (where supported)
  --quiet, -q                Minimal output (just data, no headers)

GENERAL
  setup                      Configure CLI settings
  doctor                     Check server plugins and feature availability
  list                       List all apps
  create <name>              Create a new app
  destroy [app]              Permanently delete an app

APP INFO
  info [app]                 Show app information
  logs [app] [--num N]       View app logs (default: 100 lines)
  logs:follow [app]          Follow app logs in real-time

CONFIGURATION
  config [app]               Show environment variables
  config:set [app] K=V...    Set environment variables
  config:unset [app] K...    Remove environment variables

PROCESS MANAGEMENT
  restart [app]              Restart app
  start [app]                Start app
  stop [app]                 Stop app
  scale [app] [web=N...]     View or set process scaling
  shell [app]                Open interactive shell in app

DEPLOYMENT
  deploy [app] [branch]      Deploy app via git push
  rollback [app] [version]   Rollback to previous release
  releases [app]             List releases

DEPLOY LOCKS
  lock [app] [reason]        Lock app (block deployments)
  unlock [app]               Unlock app (allow deployments)
  lock:status [app]          Check lock status

SSL & DOMAINS
  ssl [app] [enable|disable] Manage SSL certificates
  domains [app]              List domains
  domains add [app] <domain> Add a domain
  domains remove [app] <d>   Remove a domain

DATABASE
  db [app] info [service]         Show database info
  db [app] create [service]       Create and link database
  db [app] connect [service]      Connect to database shell
  db [app] backup [service]       Export database to local file
  db [app] backup-server [svc]    Backup to server storage
  db [app] restore <file> [svc]   Restore from backup file
  db [app] list-backups           List available backups

RUN COMMANDS
  run [app] <command>        Run one-off command

ALIASES
  alias                      List all aliases
  alias add <name> <app>     Create alias (e.g., prod -> myapp)
  alias remove <name>        Remove alias

INTERACTIVE MODE (requires fzf)
  i, interactive             Full interactive TUI with app browser
  pick                       Pick an app interactively (for piping)
  <command> -i               Interactive app selection for any command

EXAMPLES
  dokku-cli logs myapp --num 50
  dokku-cli config:set myapp DEBUG=true SECRET_KEY=abc123
  dokku-cli run myapp python manage.py migrate
  dokku-cli deploy myapp main
  dokku-cli db myapp create postgres
  dokku-cli --json list
  dokku-cli alias add prod myapp
  dokku-cli logs prod            # Uses alias
  dokku-cli i                    # Interactive mode
  dokku-cli logs -i              # Pick app, then show logs
  dokku-cli restart $(dokku-cli pick)  # Pipe app selection

CONFIGURATION
  Settings are stored in ~/.dokku-cli
  Run 'dokku-cli setup' to configure.

SHELL COMPLETIONS
  Bash: source /path/to/completions/dokku-cli.bash
  Zsh:  Add completions dir to fpath, then compinit
  Fish: cp dokku-cli.fish ~/.config/fish/completions/

EOF
}

# ─────────────────────────────────────────────────────────────────────────────
# Main
# ─────────────────────────────────────────────────────────────────────────────

# Parse global options
while [[ "$1" == -* ]]; do
    case "$1" in
        --json)
            OUTPUT_FORMAT="json"
            shift
            ;;
        --quiet|-q)
            QUIET_MODE="true"
            shift
            ;;
        --help|-h)
            cmd_help
            exit 0
            ;;
        --version|-v)
            echo "dokku-cli v2.3.0"
            exit 0
            ;;
        *)
            log_error "Unknown option: $1"
            exit 1
            ;;
    esac
done

# Check for -i flag (interactive app selection)
INTERACTIVE_SELECT=false
if [[ "$2" == "-i" ]] || [[ "$3" == "-i" ]]; then
    INTERACTIVE_SELECT=true
fi

case "${1:-help}" in
    # General
    setup)          cmd_setup ;;
    doctor)         cmd_doctor ;;
    list|ls)        cmd_list ;;
    create)         cmd_create "$2" ;;
    destroy|delete) cmd_destroy "$2" ;;

    # Info
    info|status)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            [ -n "$app" ] && cmd_info "$app"
        else
            cmd_info "$2"
        fi
        ;;
    logs)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            [ -n "$app" ] && cmd_logs "$app" "$3"
        else
            cmd_logs "$2" "$3"
        fi
        ;;
    logs:follow|lf)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            [ -n "$app" ] && cmd_logs_follow "$app"
        else
            cmd_logs_follow "$2"
        fi
        ;;

    # Config
    config)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            [ -n "$app" ] && cmd_config "$app"
        else
            cmd_config "$2"
        fi
        ;;
    config:set)     shift; cmd_config_set "$@" ;;
    config:unset)   shift; cmd_config_unset "$@" ;;

    # Process
    restart)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            [ -n "$app" ] && cmd_restart "$app"
        else
            cmd_restart "$2"
        fi
        ;;
    start)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            [ -n "$app" ] && cmd_start "$app"
        else
            cmd_start "$2"
        fi
        ;;
    stop)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            [ -n "$app" ] && cmd_stop "$app"
        else
            cmd_stop "$2"
        fi
        ;;
    scale)          shift; cmd_scale "$@" ;;
    shell|sh)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            [ -n "$app" ] && cmd_shell "$app"
        else
            cmd_shell "$2"
        fi
        ;;

    # Deploy
    deploy|push)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            if [ -n "$app" ]; then
                branch=$(select_branch)
                [ -n "$branch" ] && cmd_deploy "$app" "$branch"
            fi
        else
            cmd_deploy "$2" "$3"
        fi
        ;;
    rollback|rb)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            [ -n "$app" ] && cmd_rollback "$app" "$3"
        else
            cmd_rollback "$2" "$3"
        fi
        ;;
    releases)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            [ -n "$app" ] && cmd_releases "$app"
        else
            cmd_releases "$2"
        fi
        ;;

    # Deploy Locks
    lock)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            [ -n "$app" ] && cmd_lock "$app" "$3"
        else
            cmd_lock "$2" "$3"
        fi
        ;;
    unlock)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            [ -n "$app" ] && cmd_unlock "$app"
        else
            cmd_unlock "$2"
        fi
        ;;
    lock:status)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            [ -n "$app" ] && cmd_lock_status "$app"
        else
            cmd_lock_status "$2"
        fi
        ;;

    # SSL & Domains
    ssl)
        if [ "$INTERACTIVE_SELECT" == "true" ]; then
            app=$(cmd_pick)
            [ -n "$app" ] && cmd_ssl "$app" "$3"
        else
            cmd_ssl "$2" "$3"
        fi
        ;;
    domains)        shift; cmd_domains "$@" ;;

    # Database
    db)             shift; cmd_db "$@" ;;

    # Run
    run)            shift; cmd_run "$@" ;;

    # Aliases
    alias)          shift; cmd_alias "$@" ;;

    # Interactive mode
    i|interactive)  cmd_interactive ;;
    pick)           cmd_pick ;;

    # Help
    help)           cmd_help ;;

    *)
        log_error "Unknown command: $1"
        echo "Run 'dokku-cli help' for usage"
        exit 1
        ;;
esac
